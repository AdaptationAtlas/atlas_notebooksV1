---
pagetitle: "Explore the Datasets"
nb-author:
  - Brayden Youngberg
---

```{ojs}
import { heroImage } from "/helpers/hero.js";
hero_url = "./../../images/explore.webp";

hero = heroImage(notebookTitle, hero_url);
html`${hero}`;
```

```{ojs}
import { atlasTOC } from '/helpers/toc.ojs' 
{
  await nbText // force wait/reload with nbText to load so headings have correct labels/languages
  return atlasTOC({
      heading: `<b>${_lang({en:"In this notebook", fr:"Dans ce notebook"})}</b>`,
      skip: [notebookTitle, "notebook-title", "Appendix", "source-code"]
      })
}
```

```{ojs}
viewof prettyLanguageView = {
  return Inputs.bind(
    Inputs.radio(languages, {
      label: _lang({en: "Language", fr: "Langue"}),
      format: (d) => d.label
    }),
    viewof language
  );
}
```

```{ojs}
md`# ${_lang(nbText.overview.title)}

_${_lang(nbText.overview.subTitle)}_

${_lang(nbText.overview.text)}`;
```

```{ojs}
html`
  <div style="
    margin:16px 0;
    padding:14px 18px;
    border-radius:8px;
    background:linear-gradient(135deg, #4f7bd9, #6fa8dc);
    color:#ffffff;
  ">
    <div style="
      font-size:1.15rem;
      font-weight:600;
      margin-bottom:4px;
    ">
      ${_lang({
        en: "Looking for raster maps?",
        fr: "Vous cherchez des cartes raster ?",
      })}
    </div>

    <div style="
      font-size:0.95rem;
      line-height:1.4;
    ">
      ${_lang({
        en: "Raster layers are available in our previous Explore view.",
        fr: "Les couches raster sont disponibles dans l’ancienne vue Explorer.",
      })}
      <a
        href="http://agadaptationatlas-stage.org.s3-website-us-west-2.amazonaws.com/explore"
        target="_blank"
        rel="noopener noreferrer"
        style="
          color:#ffffff;
          font-weight:600;
          text-decoration:underline;
          margin-left:4px;
        "
      >
        ${_lang({
          en: "Open Explore →",
          fr: "Ouvrir Explorer →",
        })}
      </a>
    </div>
  </div>
`;
```

```{ojs}
md`# ${_lang(nbText.selectCategory.title_main)}`;
```

```{ojs}
md`### ${_lang(nbText.selectCategory.title)}
${_lang(nbText.selectCategory.text)}`;
```

```{ojs}
viewof atlas_cat = Inputs.radio(["Hazard", "Exposure", "Vulnerability"], {
  label: _lang(nbText.selectCategory.selector.title),
  value: "Hazard",
  format: (l) =>  _lang(nbText.selectCategory.selector.options[l].title)
})
```

```{ojs}
{
  return md`${_lang(nbText.selectCategory.selector.options[atlas_cat].description)}`
}
```

```{ojs}
md`### ${_lang(nbText.selectVars.title)}
${_lang(nbText.selectVars.text)}`;
```

```{ojs}
definitions = create_definitions(atlas_cat);
```

```{ojs}
viewof DataSelector_form = {
  const form_elements = {
    hazardGroup_form:
      atlas_cat === "Hazard"
        ? Inputs.form(
            {
              hazard_sel: ScrollingMultiSelect_collapsible(
                // Object.keys(hazard_dict),
                new Map(
                  Object.entries(hazard_dict).map(([key, value]) => [
                    _lang(nbText.general.hazards[key]),
                    key
                  ])
                ),
                {
                  label: _lang(nbText.selectVars.forms.Hazard.selectors.hazard.title), 
                  values: Object.keys(hazard_dict),
                }
              ),
              timeperiod_sel: ScrollingMultiSelect_collapsible(
                new Map([
                  [_lang(nbText.selectVars.forms.Hazard.selectors.period.options.baseline), "historic"],
                  ["2021-2040", "2021_2040"],
                  ["2041-2060", "2041_2060"]
                ]),
                {
                  label: _lang(nbText.selectVars.forms.Hazard.selectors.period.title),
                  values: ["historic", "2021_2040", "2041_2060" ]
                }
              )
            },
            {
              template: (inputs) =>
                html`<h4>${_lang(nbText.selectVars.forms.Hazard.mainTitle)}</h4><div style="display: flex; gap: 2em;"> ${Object.values(
                  inputs
                )}</div>`
            }
          )
        : "",
    vulnerabilityGroup_form:
      atlas_cat === "Vulnerability"
        ? Inputs.form(
            {
              vulnerability_sel: ScrollingMultiSelect_collapsible(
                ["Education", "Poverty", "Gender"],
                {
                  label: _lang(nbText.selectVars.forms.Vulnerability.selectors.variable.title),
                  values: ["Education", "Poverty", "Gender"],
                  format: (l) => _lang(nbText.selectVars.forms.Vulnerability.selectors.variable.options[l])
                }
              )
            },
            {
              template: (inputs) =>
                html`<h4>${_lang(nbText.selectVars.forms.Vulnerability.mainTitle)}</h4><div style="display: flex; gap: 2em;"> ${Object.values(
                  inputs
                )}</div>`
            }
          )
        : "",
    exposureGroup_form:
      atlas_cat === "Exposure"
        ? Inputs.form(
            {
              exposureGroup_sel: ScrollingMultiSelect_collapsible(
                // Object.values(commodities).flat(),
                ["Crop", "Livestock", "Population"],
                {
                  label: "Exposure Category",
                  values: ["Crop", "Livestock", "Population"],
                  format: (l) => _lang(nbText.selectVars.forms.Exposure.selectors.variable.options[l])
                }
              )
            },
            {
              template: (inputs) =>
                html`<h4>${_lang(nbText.selectVars.forms.Exposure.mainTitle)}</h4><div style="display: flex; gap: 2em;"> ${Object.values(
                  inputs
                )}</div>`
            }
          )
        : ""
  };

  return Inputs.form(form_elements);
}
```

```{ojs}
md`### ${_lang(nbText.selectGeog.title)}
${_lang(nbText.selectGeog.text)}`;
```

```{ojs}
viewof admin_aggregationLevel = {
  const admin_choices = ['admin0_name', 'admin1_name', 'admin2_name']

  let radio = Inputs.radio(admin_choices, {
    label: _lang(nbText.selectGeog.selectors.aggregationLvl.title),
    value: "admin1_name",
    format: (l) => _lang(nbText.selectGeog.selectors.aggregationLvl.options[l])
  });
  let selectors = radio.querySelectorAll("input[name=input]");
  let labels = radio.querySelectorAll("label");
  if (selectors && selectors[2] && country === 'SSA') {
    selectors[2].title = _lang(nbText.selectGeog.selectors.aggregationLvl.warning);
  }
  if (labels && labels[2] && country === 'SSA') {
    labels[3].title =
      _lang(nbText.selectGeog.selectors.aggregationLvl.warning);
  labels[3].style.color = "#b8310f";
  }
  return radio;
}
```

```{ojs}
{
  let adminOptions = [
    Inputs.bind(
      Inputs.select(admin0_names, { label: _lang(nbText.selectGeog.selectors.admin0_name.title),
                                   value: "SSA",
                                  format: l => _lang(nbText.general.adminNames[l]) || l}),
      viewof country
    )
  ];
  
  if (["admin1_name", "admin2_name"].includes(admin_aggregationLevel)) {
    adminOptions.push(
      Inputs.bind(
        Inputs.select(admin1_names, 
                      { 
                        label: _lang(nbText.selectGeog.selectors.admin1_name.title),
                        format: l => _lang(nbText.general.adminNames[l]) || l
                      }),
        viewof admin1_sel
      )
    );
  } 
  
  if (admin_aggregationLevel === "admin2_name") {
    adminOptions.push(
      Inputs.bind(
        Inputs.select(admin2_names, { label: _lang(nbText.selectGeog.selectors.admin2_name.title),
                     format: l => _lang(nbText.general.adminNames[l]) || l
                                    }),
        viewof admin2_sel
      )
    );
  }
  return Inputs.form(adminOptions, {
    template: (inputs) =>
      htl.html`<div style="display: flex; gap: 3em">${inputs}</div>`
  });
}
```

```{ojs}
{
  const levelLabel = _lang(
    nbText.selectGeog.selectors.aggregationLvl.options[admin_aggregationLevel]
  ).toLowerCase()

  const levelText = _lang({
    en: `at the ${levelLabel} level`,
    fr: `au niveau ${levelLabel}`
  })

  let mainText = _lang({
    en: `Viewing ${_lang(nbText.general.adminNames[country])}`,
    fr: `Affichage de ${_lang(nbText.general.adminNames[country])}`
  })

  if (admin_aggregationLevel === "admin2_name" && admin1_sel !== "Full Country") {
    mainText += _lang({
      en: `, ${admin1_sel}`,
      fr: `, ${admin1_sel}`
    })
  }

  let highlightText = ""

  if (admin_aggregationLevel === "admin1_name" && admin1_sel !== "Full Country") {
    highlightText = _lang({
      en: `${admin1_sel} is highlighted`,
      fr: `${admin1_sel} est mis en surbrillance`
    })
  } else if (
    admin_aggregationLevel === "admin2_name" &&
    admin2_sel !== "Full Region"
  ) {
    highlightText = _lang({
      en: `${admin2_sel} is highlighted`,
      fr: `${admin2_sel} est mis en surbrillance`
    })
  }

  return html`
    <p style="font-size:1.3rem; font-weight:600; margin:0 0 4px 0;">
      ${_lang({
        en: "Selection overview:",
        fr: "Aperçu de la sélection :"
      })}
    </p>
    <p style="font-size:1.15rem; margin:0; padding-left:0.75rem;">
      <strong>
        ${mainText} ${levelText}. <br>
        ${highlightText ? `${highlightText}.` : ""}
      </strong>
    </p>
  `
}
```

```{ojs}
md`# ${_lang(nbText.ViewExplore.title)}
${_lang(nbText.ViewExplore.text)}`;
```

```{ojs}
viewof previewType = Inputs.radio(["Map", "Table", "Plot"], {
  //, "Interactive Map",
  // Icons to these would be pretty
  value: "Map",
  label: _lang(nbText.ViewExplore.selectors.preview.title),
  format: (l) => _lang(nbText.ViewExplore.selectors.preview.options[l])
})
```

```{ojs}
viewof data_to_visualise = {
  if (previewType === "Map") {
    return generateMapForm()
  } else if (previewType === "Table") {
    return Inputs.search(NbData["explore_data"], {placeholder: _lang(nbText.general.search)});
  } else if (previewType === "Plot") {
    return generatePlotForm()
  }
  
  function generateMapForm() {
    const form_elements = [];
    if (atlas_cat === "Hazard") {
      let hazardOptions = DataSelector_form.hazardGroup_form.hazard_sel;
      form_elements.push(
        Inputs.bind(
          Inputs.select(
            hazardOptions.map((value) => value),
            // new Map(
            //   hazardOptions.map((value) => [_lang(nbText.selectVars.forms.Hazard.selectors.hazard.options[value]), value])
            // ),
            { label: _lang(nbText.selectVars.forms.Hazard.selectors.hazard.title),
              format: l => _lang(nbText.general.hazards[l])
            }
          ),
          viewof hazard_sel
        )
      );
      let timePeriodOptions = DataSelector_form.hazardGroup_form.timeperiod_sel;
      form_elements.push(
        Inputs.bind(
          Inputs.select(
            timePeriodOptions.map((value) => value),
            // new Map(
            //   timePeriodOptions.map((value) => [timePeriod_dict[value], value])
            // ),
            { label: _lang(nbText.selectVars.forms.Hazard.selectors.period.title),
              format: l => _lang(nbText.selectVars.forms.Hazard.selectors.period.options[l]) || l
            }
          ),
          viewof time_sel
        )
      );
      if (time_sel !== "historic") {
        form_elements.push(
          Inputs.bind(
            Inputs.select(["SSP245", "SSP585"], { label: _lang(nbText.ViewExplore.selectors.visualiseVars.hazards.scenario.title)}),
            viewof ssp_sel
          )
        );
      }
    }
    
    if (atlas_cat === "Vulnerability") {
      form_elements.push(
        Inputs.bind(
          Inputs.select(
            DataSelector_form.vulnerabilityGroup_form.vulnerability_sel,
            {
              label: _lang(nbText.selectCategory.selector.options.Vulnerability.title),
              format: l => _lang(nbText.selectVars.forms.Vulnerability.selectors.variable.options[l])||l
              // label: "Adaptive Capacity"
            }
          ),
          viewof ac_cat
        )
      );
      if (ac_cat === "Gender") {
        let ac_subcats = Object.keys(vulnerability_dict["gender"])
        form_elements.push(
          Inputs.bind(
            Inputs.select(ac_subcats, {
              label: _lang(nbText.ViewExplore.selectors.visualiseVars.vulnerability.gender.title),
              format: l => _lang(nbText.ViewExplore.selectors.visualiseVars.vulnerability.gender.options[l])
            }),
            viewof ac_subcat
          )
        );
      } else if (ac_cat === "Poverty") {
        // let ac_subcats = new Map(
        //   Object.entries(vulnerability_dict["poverty"]).map(([key, value]) => [
        //     value,
        //     key
        //   ])
        // );
        let ac_subcats = Object.keys(vulnerability_dict["poverty"])
        form_elements.push(
          Inputs.bind(
            Inputs.select(ac_subcats, {
              label:  _lang(nbText.ViewExplore.selectors.visualiseVars.vulnerability.poverty.title),
              format: l => _lang(nbText.ViewExplore.selectors.visualiseVars.vulnerability.poverty.options[l])
            }),
            viewof ac_subcat
          )
        );
      }
    }
    if (atlas_cat === "Exposure") {
      let subTitle;
      let subSelections;
      if (exposure_cat === "Population") {
        subTitle = _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.population.title);
        subSelections = ["total_pop", "rural_pop", "urban_pop"]
      } else {
        subTitle = _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.commodity.title);
        subSelections = commodities[exposure_cat];
      }

      form_elements.push(
        Inputs.bind(
          Inputs.select(
            DataSelector_form.exposureGroup_form.exposureGroup_sel,
            {
              label: _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.title),
              format: l => _lang(nbText.selectVars.forms.Exposure.selectors.variable.options[l])
            }
          ),
          viewof exposure_cat
        )
      );
      form_elements.push(
        Inputs.bind(
          Inputs.select(subSelections, {
            label: subTitle,
            format: l => _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.population.options[l] || nbText.general.commodities[l])
          }),
          viewof exposure_subCat
        )
      );
      if (exposure_cat !== "Population") {
        form_elements.push(
                    Inputs.bind(
              Inputs.select(exposure_var_choices, {
                label: _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.title),
                format: (t) => _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.options[t])
              }),
              viewof exposure_var
            )
        )
      }
    }
    return Inputs.form(form_elements, {
      template: (inputs) =>
        htl.html`<h3>${_lang(nbText.ViewExplore.selectors.visualiseVars.titleMap)}</h3> <div style="display: flex; gap: 3em">${inputs}</div>`
    });
  }
  
  function generatePlotForm() {
    let form_elements = [];
    let title = _lang(nbText.ViewExplore.selectors.visualiseVars.titlePlot);
    if (atlas_cat === "Exposure") {
      form_elements.push(
        Inputs.bind(
          Inputs.select(
            DataSelector_form.exposureGroup_form.exposureGroup_sel,
            {
              label: _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.title),
              format: l => _lang(nbText.selectVars.forms.Exposure.selectors.variable.options[l])
            }
          ),
          viewof exposure_cat
        )
      );
      if (exposure_cat.includes("Crop") || exposure_cat.includes("Livestock")) {
        form_elements.push(
          Inputs.bind(
            Inputs.select(exposure_var_choices, {
              label: _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.title),
              format: (t) => _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.options[t])
            }),
            viewof exposure_var
          )
        );
      }
    }
    if (atlas_cat === "Hazard") {
      let hazardOptions = DataSelector_form.hazardGroup_form.hazard_sel;
      form_elements.push(
        Inputs.bind(
          Inputs.select(
            hazardOptions.map((value) => value),
            { label: _lang(nbText.selectVars.forms.Hazard.selectors.hazard.title),
              format: l => _lang(nbText.general.hazards[l])
            }
          ),
          viewof hazard_sel
        )
      );
    }
    if (atlas_cat === "Vulnerability") {
      title = "";
    }
    return Inputs.form(form_elements, {
      template: (inputs) =>
        htl.html`<h3>${title}</h3> <div style="display: flex; gap: 3em">${inputs}</div>`
    });
  }
}
```

```{ojs}
data_preview = {
  if (previewType === "Map") {
    return html`<div>${map()}</div>`;
    // } else if (previewType === "Interactive Map") {
    //   return html`<div>${MapInfo.MapLegend}</div> <div>${MapContainer}</div>`;
  } else if (previewType === "Table") {
    return html`<div>${createTable()}</div>`;
  } else if (previewType === "Plot") {
    // return html`<div>${container2}</div>`;
    return html`<div>${await createPlot()}</div>`;
  }
}
```

```{ojs}
md`# ${_lang(nbText.download.title)}`;
```

```{ojs}
viewof download_format = {
  // let downlaod_options;
  let download_options = ["Parquet", "CSV", "JSON"]; //, "GEOPARQUET", "GEOJSON"];

  return Inputs.radio(download_options, {
    label: _lang(nbText.download.selector.title),
    value: "Parquet"
  });
}
```

```{ojs}
html`<div >${download_button_initiate()}</div>`;
```

```{ojs}
md`### ${_lang(nbText.download.boundaries.title)}`;
```

```{ojs}
download_spatial_button();
```

```{ojs}
md`# ${_lang(nbText.STAC.title)}

${_lang(nbText.STAC.text)}`;
```

```{ojs}
viewof codeLanguage = Inputs.radio(["R", "Python", "NoCode"], {
  label: "Language",
  value: "NoCode",
  format: l => _lang(nbText.general[l]) || l
})
```

```{ojs}
codechunk = {

  if (codeLanguage === "NoCode") {
    return html`<iframe src ='https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/catalog.json?.language=${language.key}' style="width:100%; height: 800px;">`
  } else {
    let code_text = generate_codeText(codeLanguage)
      let markdown_code = md`
\`\`\` ${codeLanguage.toLowerCase()}
${code_text}
\`\`\``
     return html`<div style='overflow: auto; max-height: 800px; background-color:#F8F8F8;padding-left: 10px'>${markdown_code}</div>`
  }

function generate_codeText(codeLang) {
  let code_text
  switch (codeLang) {
    case "R":
      let r_adminQuery = country !== 'SSA' ? `admin_query <- 'SELECT * from "atlas-region_admin0_harmonized" WHERE admin0_name = \\'${country}\\''` : `admin_query <- 'SELECT * from "atlas-region_admin0_harmonized"'`
    code_text = `library(terra)
library(rstac)

admin_path <- '/vsis3/digital-atlas/boundaries/atlas-region_admin0_harmonized.parquet' 
${r_adminQuery}
adminBounds <- vect(admin_path, query = admin_query)
stac_path <- "https:///digital-atlas.s3.amazonaws.com/stac/public_stac/catalog.json"
stac_catalog <- read_stac(stac_path)

children <- links(stac_catalog, rel == 'child')
children_df <- do.call("rbind", lapply(children, as.data.frame))
print(children_df$title)

hazardCatalog <- link_open(children[[grep("Hazard", children)]])
print(hazardCatalog$description)
haz_children <- links(hazardCatalog, rel == 'child')
haz_children_df <- do.call("rbind", lapply(haz_children, as.data.frame))
haz_children_df$description <- sapply(haz_children, \(x) {
  child <- link_open(x)
  child$description
})

hazard_items <- link_open(haz_children[[1]]) |> 
    rstac::read_items(limit = 10)

hazard_items |> 
    rstac::items_as_tibble()

possible_filters <- items_properties(hazard_items)

meanNDWS_tifs <- hazard_items |> 
    rstac::items_filter(filter_fn = \(x) {
        (x$properties$\`atlas:hazard\` == "NDWS" 
        & x$properties$\`atlas:statistic\` == "mean") }) |>
    rstac::assets_url()

country_data <- meanNDWS_tifs |> 
    gsub(x= _, 'https://digital-atlas.s3.amazonaws.com/', '/vsis3/digital-atlas') |>
    terra::rast() |> 
    crop(adminBounds, mask = T)
    
plot(country_data)`;
      break
    case 'Python':
      code_text = `import pystac
import rasterio
import pandas as pd
from matplotlib import pyplot
from pystac_client import Client

stac_path = "https://digital-atlas.s3.amazonaws.com/stac/public_stac/catalog.json"

catalog = Client.open(stac_path)
print(catalog.title)
print(catalog.description)

children = []
for child in catalog.get_children():
    print(child)
    title = child.title
    id = child.id
    description = child.description
    self_href = child.self_href
    keywords = child.extra_fields.get('keywords') or None
    children.append({
        'title': title,
        'id': child.id,
        'description': description,
        'keywords': keywords,
        'self_href': self_href
    })

catalog_df = pd.DataFrame(children)

hazardCatalog = catalog.get_child('hazard_catalog')
print(hazardCatalog.description)

hazard_items = []
for child in hazardCatalog.get_children():
    print(child)
    title = child.title
    id = child.id
    description = child.description
    self_href = child.self_href
    keywords = child.extra_fields.get('keywords') or None
    hazard_items.append({
        'title': title,
        'id': child.id,
        'description': description,
        'keywords': keywords,
        'self_href': self_href
    })

hazardCatalog_df = pd.DataFrame(hazard_items)

hazard_timeseries = hazardCatalog.get_child('hazard_timeseries_annual')
print(hazard_timeseries.description)

possible_filters = next(hazard_timeseries.get_items()).properties.keys()
print(possible_filters)

def filter_items(item_generator:pystac.ItemCollection, filters:dict, limit:int=10):
    count = 0
    for item in item_generator:
        for key, value in filters.items():
            if item.properties.get(key) != value:
                break
        else:
            yield item
            count += 1
            if count >= limit:
                break

item_filters: {'atlas:hazard': 'NDWS', 'atlas:statistic': 'mean'}

meanNDWS_items = filter_items(hazard_timeseries.get_items(), {'atlas:hazard': 'NDWS', 'atlas:statistic': 'mean'}, limit=10)

NDWS_assets = []
for item in meanNDWS_items:
    print(item)
    assets = item.get_assets()
    for key in assets.keys():
        print(key)
        NDWS_assets.append(assets.get(key).href)


with rasterio.open(NDWS_assets[0].replace('https://digital-atlas.s3.amazonaws.com/', 's3://digital-atlas')) as src:
    print(src.meta)
    pyplot.imshow(src.read(12))
    pyplot.show()`
      break
  }
  return code_text
}
  
}
```

```{ojs}
md`# ${_lang(nbText.methods_sources.title)}`;
```

```{ojs}
md`## ${_lang(nbText.methods_sources.datasets.title)}`;
```

```{ojs}
md`### ${_lang(nbText.methods_sources.datasets.boundaries.title)}
${_lang(nbText.methods_sources.datasets.boundaries.text)}`;
```

```{ojs}
md`### ${_lang(nbText.methods_sources.datasets.Hazards.title)}
${_lang(nbText.methods_sources.datasets.Hazards.text)}`;
```

```{ojs}
md`### ${_lang(nbText.methods_sources.datasets.exposureDS.title)}`;
```

```{ojs}
md`#### ${_lang(nbText.methods_sources.datasets.exposureDS.vopHA.title)}
${_lang(nbText.methods_sources.datasets.exposureDS.vopHA.text)}`;
```

```{ojs}
md`#### ${_lang(nbText.methods_sources.datasets.exposureDS.population.title)}
${_lang(nbText.methods_sources.datasets.exposureDS.population.text)}`;
```

```{ojs}
md`### ${_lang(nbText.methods_sources.datasets.acDS.title)}`;
```

```{ojs}
md`#### ${_lang(nbText.methods_sources.datasets.acDS.FemaleWellbeing.title)}
 ${_lang(nbText.methods_sources.datasets.acDS.FemaleWellbeing.text)}`;
```

```{ojs}
md`#### ${_lang(nbText.methods_sources.datasets.acDS.poverty.title)}
${_lang(nbText.methods_sources.datasets.acDS.poverty.text)}`;
```

# Appendix {.hidden}

```{ojs}
md`## Imports`;
```

```{ojs}
GEOS = {
  const initgeosJs = (await import("https://cdn.skypack.dev/geos-wasm@2.0.0"))
    .default;
  const geos = await initgeosJs();

  function geosGeomFromWKB(wkb) {
    const wkbPtr = geos.Module._malloc(wkb.length); //Allocate memory for the geom
    geos.Module.HEAPU8.set(wkb, wkbPtr);
    const geomPtr = geos.GEOSGeomFromWKB_buf(wkbPtr, wkb.length);
    geos.Module._free(wkbPtr);
    return geomPtr;
  }
  
  const geosGeomToGeojson = (
    await import("https://cdn.skypack.dev/geos-wasm/helpers")
  ).geosGeomToGeojson;

  return { geosGeomToGeojson, geosGeomFromWKB, geos };
}
```

```{ojs}
geo_db = {
  let db = await DuckDBClient.of({
    // admin0_geom: FileAttachment("atlas-region_admin0_simplified.parquet"),
    admin1_geom: FileAttachment("atlas-region_admin1_simplified.parquet")
  });
  await db.query(`
    CREATE VIEW admin2_geom AS
    SELECT *
    FROM read_parquet("${resolveWindowsCacheIssue(
      "https://digital-atlas.s3.amazonaws.com/boundaries/atlas-region_admin2_simplified.parquet"
    )}")`);
  return db;
}
```

```{ojs}
db = {
  // const db = await DuckDBClient.of();
  let db = await DuckDBClient.of({
    // admin0_geom: FileAttachment("atlas-region_admin0_simplified.parquet"),
    // admin1_geom: FileAttachment("atlas-region_admin1_simplified.parquet")
  });
  // await db.query(`
  //   CREATE VIEW admin2_geom AS
  //   SELECT *
  //   FROM read_parquet("https://digital-atlas.s3.amazonaws.com/boundaries/atlas-region_admin2_simplified.parquet")`);
  // await db.query(`
  //   CREATE VIEW exposurePopulation AS
  //   SELECT *
  //   FROM read_parquet('${s3Paths["Population"]}')`);
  // await db.query(`
  //   CREATE VIEW Exposure AS
  //   SELECT *
  //   FROM read_parquet('${s3Paths["Exposure"]["exposure"]}')`);
  // // await build_DB(db, atlas_cat);
  // await db.query(`
  //     CREATE VIEW exposureCrop AS
  //     SELECT *
  //     FROM read_parquet('${s3Paths["Exposure"]["cropVOP"]}')
  //     UNION ALL
  //     SELECT *
  //     FROM read_parquet('${s3Paths["Exposure"]["cropHA"]}')
  //   `);
  // await db.query(`
  //     CREATE VIEW exposureLivestock AS
  //     SELECT *
  //     FROM read_parquet('${s3Paths["Exposure"]["livestockVOP"]}')
  //     WHERE "crop" NOT LIKE '%total%'
  //     UNION ALL
  //     SELECT *
  //     FROM read_parquet('${s3Paths["Exposure"]["livestockNum"]}')
  //     WHERE "crop" NOT LIKE '%total%'
  //   `);
  await db.query(`
      CREATE VIEW Hazard AS
      SELECT admin0_name, admin1_name, admin2_name, scenario, timeframe, hazard, value
      FROM read_parquet('${s3Paths["Hazard"]}')
    `);
  return await db;
}
```

```{ojs}
CheckORAdd_ExposureTable = async (db) => {
  let tables = await db.describeTables().then((r) => r.map((d) => d.name));
  if (!tables.includes("Exposure")) {
    await db.query(`
    CREATE VIEW exposurePopulation AS
    SELECT *
    FROM read_parquet('${s3Paths["Population"]}')`);
    await db.query(`
    CREATE VIEW Exposure AS
    SELECT *
    FROM read_parquet('${s3Paths["Exposure"]["exposure"]}')`);
    await db.query(`
      CREATE VIEW exposureCrop AS
          SELECT admin0_name, admin1_name, admin2_name, crop, exposure, "value" as old_value, CASE 
            WHEN value < 1000 THEN 0
              ELSE value
            END AS value
          FROM read_parquet('${s3Paths["Exposure"]["cropVOP"]}')
          UNION ALL
          SELECT admin0_name, admin1_name, admin2_name, crop, exposure, "value" as old_value, CASE
            WHEN value < 1000 THEN 0
              ELSE value
            END AS value
          FROM read_parquet('${s3Paths["Exposure"]["cropHA"]}')`);
    await db.query(`
      CREATE VIEW exposureLivestock AS
      SELECT *
      FROM read_parquet('${s3Paths["Exposure"]["livestockVOP"]}')
      WHERE "crop" NOT LIKE '%total%'
      UNION ALL
      SELECT *
      FROM read_parquet('${s3Paths["Exposure"]["livestockNum"]}')
      WHERE "crop" NOT LIKE '%total%'
    `);
  }
};
```

```{ojs}
CheckORAdd_VulnTable = async (db) => {
  let tables = await db.describeTables().then((r) => r.map((d) => d.name));
  if (!tables.includes("Vulnerability")) {
    await db.query(`
      CREATE VIEW Vulnerability AS
      SELECT *
      FROM read_parquet('${s3Paths["Vulnerability"]}')
    `);
  }
};
```

```{ojs}
import { ScrollingMultiSelect_collapsible } from "@brayden-youngberg/scrolling-multi-select";
```

```{ojs}
turfRewind = require("@turf/turf").then((t) => t.rewind);
```

```{ojs}
import { resolveWindowsCacheIssue } from "72281be2f13a0a72";
```

```{ojs}
md`## Notebook Variables`;
```

```{ojs}
notebookTitle = _lang({
  en: "Explore the Datasets",
  fr: "Explorer les jeux de données",
});
```

```{ojs}
timePeriod_dict = new Object({
  historic: "Baseline",
  "2021_2040": "2040",
  "2041_2060": "2060",
});
```

```{ojs}
s3Paths = new Object({
  Population: resolveWindowsCacheIssue(
    "s3://digital-atlas/population/worldpop_2020/population_adminALL.parquet",
  ),
  Exposure: {
    exposure: resolveWindowsCacheIssue(
      "s3://digital-atlas/exposure/exposure_adminALL.parquet",
    ),
    cropVOP: resolveWindowsCacheIssue(
      "s3://digital-atlas/exposure/mapspam/processed/crop_ha_adm.parquet",
    ),
    cropHA: resolveWindowsCacheIssue(
      "s3://digital-atlas/exposure/mapspam/processed/crop_vop_adm.parquet",
    ),
    livestockVOP: resolveWindowsCacheIssue(
      "s3://digital-atlas/exposure/livestock/processed/livestock_vop_adm.parquet",
    ),
    livestockNum: resolveWindowsCacheIssue(
      "s3://digital-atlas/exposure/livestock/processed/livestock_no_adm.parquet",
    ),
  },
  Hazard: resolveWindowsCacheIssue(
    "s3://digital-atlas/hazards/hazard_timeseries_mean/annual/haz_means_adm.parquet",
  ),
  Vulnerability:
    // "https://digital-atlas.s3.amazonaws.com/vulnerability/vulnerability_adm0-1-2.parquet"
    resolveWindowsCacheIssue(
      "s3://digital-atlas/vulnerability/vulnerability_adminALL.parquet",
    ),
});
```

```{ojs}
merged_scale = ["#EC5A47", "#ffb347", "#F7D732", "#a3ab2e"].reverse();
```

```{ojs}
hazard_dict = new Object({
  HSH_max: {
    name: "Max Human Heat Stress",
    thresholds: [27, 32, 41, 54],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154", "#db3a34"]
    colours: merged_scale.concat(["#B8547F"]),
  },
  HSH_mean: {
    name: "Mean Human Heat Stress",
    thresholds: [27, 32, 41, 54],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154", "#db3a34"]
    colours: merged_scale.concat(["#B8547F"]),
  },
  NDWL0: {
    name: "Number of Waterlogging Days",
    thresholds: [2, 5, 8],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  NDWS: {
    name: "Number of Days of Water Stress",
    thresholds: [15, 20, 25],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  NTx35: {
    name: "Number of Heat Stress Days for Maize",
    thresholds: [10, 20, 25],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  NTx40: {
    name: "Number of Heat Stress Days for Generic Crops",
    thresholds: [1, 5, 10],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  TAI: {
    name: "Thornthwaite's Aridity Index",
    thresholds: [40, 60, 80],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  THI_max: {
    name: "Max Cattle Thermal Humidity Index",
    thresholds: [72, 78, 90],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  THI_mean: {
    name: "Mean Cattle Thermal Humidity Index",
    thresholds: [72, 78, 90],
    // colours: ["#b7e3c9", "#ffec80", "#ffb347", "#f78154"]
    colours: merged_scale,
  },
  TAVG: {
    name: "Average Temperature",
    thresholds: [33, 36, 47],
    colours: merged_scale,
  },
  PTOT: {
    name: "Total Precipitation",
    thresholds: [1200, 1600, 1800],
    colours: merged_scale,
  },
});
```

```{ojs}
vulnerability_dict = new Object({
  gender: {
    domestic_violence: "Lack of Domestic Violence",
    gender_equity: "Gender Equity", // leaving out the 1995-2015 equity index, as the rest of the AC vars are from ~2015, which is this
    decision_making: "Decision Making Power",
    education: "Womens Education",
    family_planning: "Access to Family Planning",
    reproductive_health: "Reproductive Health",
  },
  poverty: {
    GSAP_poor215: "% under $2.15 poverty line",
    GSAP_poor365: "% under $3.65 poverty line",
    GSAP_poor685: "% under $6.85 poverty line",
  },
  education: {
    educationYrs: "Education(Yrs)",
  },
});
```

```{ojs}
plotQuery_admin = {
  if (country === "SSA") {
    return `WHERE admin1_name IS NULL`;
  } else if (country !== "SSA" && admin1_sel === "Full Country") {
    return `WHERE admin0_name = '${country}' AND admin1_name IS NULL`;
  } else if (admin1_sel !== "Full Country" && admin2_sel === "Full Region") {
    return `WHERE admin0_name = '${country}' AND admin1_name = ${admin1_sel}`;
  } else if (admin2_sel !== "Full Region") {
    return `Where admin admin0_name = '${country}' AND admin1_name = ${admin1_sel} AND admin2_name = ${admin2_sel}`;
  }
}
```

```{ojs}
mapDataQuery_admin = {
  // if (country === "SSA") {
  //   return `WHERE admin1_name IS NULL`;
  // } else if (country !== "SSA" && admin1_sel === "Full Country") {
  //   return `WHERE admin0_name = '${country}' AND admin1_name IS NULL`;
  // } else if (admin1_sel !== "Full Country" && admin2_sel === "Full Region") {
  //   return `WHERE admin0_name = '${country}' AND admin1_name = ${admin1_sel}`;
  // } else if (admin2_sel !== "Full Region") {
  //   return `Where admin admin0_name = '${country}' AND admin1_name = ${admin1_sel} AND admin2_name = ${admin2_sel}`;
  // }

  let admin_query;
  if (country === "SSA") {
    if (admin_aggregationLevel === "admin0_name") {
      admin_query = `WHERE admin1_name IS NULL`;
    } else if (admin_aggregationLevel === "admin1_name") {
      admin_query = `WHERE admin1_name IS NOT NULL AND admin2_name IS NULL`;
    } else if (admin_aggregationLevel === "admin2_name") {
      admin_query = `WHERE admin2_name IS NOT NULL`;
    }
  } else if (country !== "SSA" && admin1_sel === "Full Country") {
    if (admin_aggregationLevel === "admin0_name") {
      admin_query = `WHERE admin0_name = '${country}' AND admin1_name IS NULL`;
    } else if (admin_aggregationLevel === "admin1_name") {
      admin_query = `WHERE admin0_name = '${country}' AND admin1_name IS NOT NULL AND admin2_name IS NULL`;
    } else if (admin_aggregationLevel === "admin2_name") {
      admin_query = `WHERE admin0_name = '${country}' AND admin1_name IS NOT NULL AND admin2_name IS NOT NULL`;
    }
  } else if (admin1_sel !== "Full Country" && admin2_sel === "Full Region") {
    if (admin_aggregationLevel === "admin1_name") {
      admin_query = `WHERE admin0_name = '${country}' AND admin1_name ='${admin1_sel}' AND admin2_name IS NULL`;
    } else if (admin_aggregationLevel === "admin2_name") {
      admin_query = `WHERE admin0_name = '${country}' AND admin1_name ='${admin1_sel}' AND admin2_name IS NOT NULL`;
    }
  } else if (admin2_sel !== "Full Region") {
    admin_query = `WHERE admin0_name = '${country}' AND admin1_name ='${admin1_sel}' AND admin2_name ='${admin2_sel}'`;
  }
  return admin_query;
}
```

```{ojs}
plotQuery2_admin = {
  if (country === "SSA") {
    return `WHERE admin1_name IS NULL`;
  } else if (country !== "SSA" && admin1_sel === "Full Country") {
    return `WHERE admin0_name = '${country}' AND admin1_name IS NOT NULL AND admin2_name IS NULL`;
  } else if (admin1_sel !== "Full Country" && admin2_sel === "Full Region") {
    return `WHERE admin0_name = '${country}' AND admin1_name = '${admin1_sel}' AND admin2_name IS NOT NULL`;
  } else if (admin2_sel !== "Full Region") {
    return `WHERE admin0_name = '${country}' AND admin1_name = '${admin1_sel}' AND admin2_name = '${admin2_sel}'`;
  }
}
```

```{ojs}
all_data_query = {
  let db_query;
  if (atlas_cat === "Vulnerability") {
    db_query = `
      SELECT *,
      FROM Vulnerability
      ${mapDataQuery_admin}
      AND "group" in ('${DataSelector_form.vulnerabilityGroup_form.vulnerability_sel
        .join("', '")
        .toLowerCase()}')`;
  } else if (atlas_cat === "Exposure") {
    db_query = `
      SELECT *
      FROM Exposure
      ${mapDataQuery_admin}
      AND "group" in ('${DataSelector_form.exposureGroup_form.exposureGroup_sel
        .join("', '")
        .toLowerCase()}')`;
  } else if (atlas_cat === "Hazard") {
    db_query = `
    SELECT *
    FROM Hazard
    ${mapDataQuery_admin}
    AND "hazard" IN ('${DataSelector_form.hazardGroup_form.hazard_sel.join(
      "', '"
    )}')
    AND "timeframe" IN ('${DataSelector_form.hazardGroup_form.timeperiod_sel.join(
      "', '"
    )}')`;
  }

  return db_query;
}
```

```{ojs}
map_query = {
  let db_query;
  if (atlas_cat === "Exposure") {
    if (exposure_cat === "Population") {
      // const pop_group = exposure_subCat.split(" ")[0].toLowerCase() + "_pop";
      db_query = `
      SELECT admin0_name, admin1_name, admin2_name, ${exposure_subCat} AS value
      FROM "${atlas_cat.toLowerCase() + exposure_cat}"
      `;
    } else {
      let exposure;
      exposure = exposure_var;
      db_query = `
      SELECT *
      FROM "${atlas_cat.toLowerCase() + exposure_cat}"
      WHERE "exposure" LIKE '${exposure}'
      AND "crop" LIKE '${exposure_subCat}'`;
    }
  } else if (atlas_cat === "Vulnerability") {
    db_query = `
      SELECT *
      FROM Vulnerability
      WHERE "group" LIKE '${ac_cat.toLocaleLowerCase()}'
  `;
    if (ac_cat === "Gender" || ac_cat === "Poverty") {
      db_query = db_query + `AND "variable" LIKE '${ac_subcat}'`;
    }
  } else if (atlas_cat === "Hazard") {
    db_query = `
    SELECT *
    FROM Hazard
    WHERE "hazard" LIKE '${hazard_sel}'
    AND "scenario" LIKE '${ssp_sel.toLowerCase()}' AND "timeframe" LIKE '${time_sel.toLowerCase()}'`;
  } else {
    db_query = null
  }
  return db_query;
}
```

```{ojs}
NbData = {
  if (atlas_cat === "Vulnerability") {
    await CheckORAdd_VulnTable(db);
  } else if (atlas_cat === "Exposure") {
    await CheckORAdd_ExposureTable(db);
  } else {
  }
  return {
    explore_data: await db.query(all_data_query),
    map_data: await db.query(map_query)
  };
}
```

```{ojs}
admin_index = d3.index(
  NbData["map_data"],
  (d) => d.admin0_name,
  (d) => d.admin1_name,
  (d) => d.admin2_name,
);
```

```{ojs}
crop_groups = new Object({
  cattle: ["cattle_tropical", "cattle_highland"],
  poultry: ["poultry_tropical", "poultry_highland"],
  pigs: ["pigs_tropical", "pigs_highland"],
  "Small Ruminants": [
    "sheep_tropical",
    "sheep_highland",
    "goats_tropical",
    "goats_highland",
  ],
  rootsTuber: ["potato", "sweet potato", "yams", "cassava"],
  cereals: [
    "wheat",
    "rice",
    "maize",
    "barley",
    "pearl millet",
    "small millet",
    "sorghum",
  ],
  legumes: [
    "bean",
    "chickpea",
    "cowpea",
    "pigeonpea",
    "lentil",
    "groundnut",
    "soybean",
  ],
  fruitVeg: ["plantain", "coconut", "banana"],
  nonEdible: [
    "cocoa",
    "rapeseed",
    "sesameseed",
    "oilpalm",
    "cotton",
    "tea",
    "tobacco",
    "arabica coffee",
    "sunflower",
    "sugarcane",
    "sugarbeet",
    "robusta coffee",
  ],
});
```

```{ojs}
md`## Format helpers`;
```

```{ojs}
formatDollar = new Intl.NumberFormat("en-US", {
  notation: "compact",
  compactDisplay: "short",
  style: "currency",
  currency: "usd",
}).format;
```

```{ojs}
formatBigNums = new Intl.NumberFormat("en-US", {
  notation: "compact",
  compactDisplay: "short",
}).format;
```

```{ojs}
function format_val(val, unit) {
  switch (unit) {
    case "dollar":
      return formatDollar(val);
    case "total":
      return formatBigNums(val);
    case "total_ha":
      return `${formatBigNums(val)} /ha`;
    case "index":
      return val.toFixed(2);
    case "percent":
      return `${(val * 100).toFixed(2)}%`;
    case "percent_NoDecimal":
      return `${(val * 100).toFixed(0)}%`;
    default:
      if (typeof unit === "number") {
        return (val * unit).toFixed(1);
      }
      return val; // Default case if unit doesn't match any condition
  }
}
```

```{ojs}
var_unit = {
  if (atlas_cat === "Hazard") {
    const clean_haz = hazard_sel.split("_")[0];
    return unit_dict[atlas_cat][clean_haz];
  }

  if (atlas_cat === "Exposure") {
    if (exposure_var === "vop") {
      return unit_dict[atlas_cat][exposure_var];
    } else if (exposure_cat === "Population") {
      return unit_dict[atlas_cat]["populationTotal"];
    } else {
      const clean_var = exposure_var;
      const full_var = exposure_cat.toLowerCase() + clean_var;
      return unit_dict[atlas_cat][full_var]; //.toLowerCase()
    }
  }

  if (atlas_cat === "Vulnerability") {
    return unit_dict[atlas_cat][ac_cat];
  }
}
```

```{ojs}
unit_dict = {
  let day_lab = _lang(nbText.general.units.days)
  let index_lab =  _lang(nbText.general.units.index)
  let yr_lab = _lang(nbText.general.units.yrs)
  let pop_lab = _lang(nbText.general.units.num_people)
  let numAnimal_lab = _lang(nbText.general.units.num_animals)
  
  return {
    Exposure: {
      vop: { label: "IND2005", category: "dollar" },
      livestocknumber: { label: numAnimal_lab, category: "total" },
      cropha: { label: "Ha", category: "total" },
      populationTotal: { label: pop_lab, category: "total" }
    },
    Hazard: {
      THI: { label: index_lab, category: "total" },
      TAVG: { label: "ºC", category: "total" },
      TAI: { label: "%", category: "total" },
      PTOT: { label: "mm", category: "total" },
      NTx35: { label: day_lab, category: "total" },
      NTx40: { label: day_lab, category: "total" },
      NDWS: { label: day_lab, category: "total" },
      NDWL0: { label: day_lab, category: "total" },
      HSH: { label: index_lab, category: "total" }
    },
    Vulnerability: {
      Gender: { label: index_lab, category: "index" },
      Education: { label: yr_lab, category: "total" },
      Poverty: { label: "%", category: "percent" }
    }
  }
}
```

```{ojs}
md`## Download Helpers`;
```
```{=html}
<style>
  .atlas_button {
    text-decoration: none !important;
    background: #FFFFFF;
    border: 1px solid black;
    padding: 10px 20px;
  };

  .atlas_button:hover {
    background: #EFEFEF;
  };
</style>
```

```{ojs}
download_button_initiate = () => {
  const button = html`<a class=atlas_button>${_lang(nbText.download.button.prepare)}</a>`;

  button.onclick = async () => {
    document.body.style.cursor = "wait";
    button.textContent = "Loading...";
    const utc_date = new Date().toISOString();
    const dateregex = /^(\d{4})-(\d{2})-(\d{2})/;
    const yyyymmdd = utc_date.match(dateregex)[0];
    let file_name = "adaptation-atlas_" + atlas_cat + "_" + yyyymmdd;
    let file_ext = download_format.toLowerCase();
    const full_name = file_name + "." + file_ext;

    let downloadBlob;
    if (download_format === "Parquet" || download_format === "CSV") {
      downloadBlob = await downloadTabular(
        file_name,
        file_ext,
        db,
        download_format,
        full_name,
      );
    } else if (download_format === "JSON") {
      let cleanJSON = await NbData["explore_data"].map((row) =>
        Object.fromEntries(row),
      ); // not a totally valid json, needs fixing.
      downloadBlob = new Blob([NbData["explore_data"]], {
        type: "application/json",
      });
    }
    // const size = (downloadBlob.size / 1000000).toFixed(0);
    const url = URL.createObjectURL(downloadBlob);
    const downloadButton = html`<a href="${url}" download="${full_name}" target="_blank" class="atlas_button">${_lang(nbText.download.button.download)} ${download_format} </a>`; //(~${size} mb)
    button.replaceWith(downloadButton);
    document.body.style.cursor = "default";
  };
  return button;
};
```

```{ojs}
async function downloadTabular(
  file_name,
  file_ext,
  db,
  download_format,
  full_name,
) {
  const regex = new RegExp(`${file_name}\\.${file_ext}`);
  const db_connect = await db._db;
  let files = await db_connect.globFiles("/tmp/*" + "." + file_ext);
  let file = files.find((d) => d.fileName.match(regex));
  if (files.length === 0 || file === undefined) {
    if (download_format === "PARQUET") {
      let copied = await db.query(
        `COPY (${all_data_query}) to '/tmp/${full_name}' (FORMAT 'PARQUET', COMPRESSION 'snappy')`,
      );
    } else {
      let copied = await db.query(
        `COPY (${all_data_query}) to '/tmp/${full_name}' (FORMAT 'CSV', HEADER, DELIMITER ',')`,
      );
    }
    files = await db_connect.globFiles("/tmp/*" + "." + file_ext);
    file = files.find((d) => d.fileName.match(regex));
  }
  const app_type =
    download_format === "PARQUET" ? "application/octet-stream" : "text/csv";
  const buffer = await db_connect.copyFileToBuffer(file.fileName);
  const downloadData = new Blob([buffer], {
    type: app_type,
  });
  db_connect.dropFile(`/tmp/${full_name}`);
  return downloadData;
}
```

```{ojs}
async function downloadSpatial(
  // The issue with this one is that it needs to be long format somehow...
  file_name,
  file_ext,
  download_format,
  full_name,
) {
  if (download_format === "PARQUET") {
  }
}
```

```{ojs}
download_spatial_button = () => {
  let adm_level = admin_aggregationLevel.match(/\d+/)[0];
  let downloadBlob = new Blob([JSON.stringify(adminLevel_spatial)], {
    type: "application/geo+json",
  });
  let size = (downloadBlob.size / 1000000).toFixed(0);
  let url = URL.createObjectURL(downloadBlob);

  let button_template = _lang(nbText.download.boundaries.button);
  let btn_txt = Lang.reduceReplaceTemplateItems(button_template, [
    { name: "adminLvl", value: adm_level },
  ]);

  let downloadButton = html`<a href="${url}" download="Atlas-boundaries_admin${adm_level}.json" target="_blank" class=atlas_button>${btn_txt}</a>`;
  return downloadButton;
};
```

```{ojs}
download_metadata_button = () => {
  let downloadBlob = new Blob([","], {
    type: "text/csv",
  });
  let size = (downloadBlob.size / 1000000).toFixed(0);
  let url = URL.createObjectURL(downloadBlob);

  let downloadButton = html`<a href="${url}" download="AdaptationAtlas_metadata.csv" target="_blank" style="background: grey; color: white; padding: 10px 20px; border-radius: 50px; text-decoration: none;">Download Metadata</a>`;
  return downloadButton;
};
```

```{ojs}
md`## Geography`;
```

```{ojs}
adminLevel_spatial = {
  let admFeatures;
  if (country === "SSA") {
    if (admin_aggregationLevel === "admin0_name") {
      admFeatures = admin0_load;
    } else if (admin_aggregationLevel === "admin1_name") {
      admFeatures = admin1;
    } else if (admin_aggregationLevel === "admin2_name") {
      admFeatures = admin2;
    }
  } else if (country !== "SSA" && admin1_sel === "Full Country") {
    if (admin_aggregationLevel === "admin0_name") {
      admFeatures = admin0_load;
      // let filtered = admin0_load.features.filter(
      //   (d) => d.properties.admin0_name === country
      // );
      // // Create a new GeoJSON object with the filtered features
      // admFeatures = {
      //   type: admin0_filtered.type,
      //   features: filtered
      // };
    } else if (admin_aggregationLevel === "admin1_name") {
      admFeatures = admin1;
    } else if (admin_aggregationLevel === "admin2_name") {
      admFeatures = admin2;
    }
  } else if (country !== "SSA" && admin1_sel !== "Full Country") {
    if (admin_aggregationLevel === "admin1_name") {
      admFeatures = admin1;
      // let filtered = admin1.features.filter(
      //   (d) => d.properties.admin1_name === admin1_sel
      // );
      // // Create a new GeoJSON object with the filtered features
      // admFeatures = {
      //   type: admin1.type,
      //   features: filtered
      // };
    } else if (admin_aggregationLevel === "admin2_name") {
      admFeatures = admin2;
    }
  }

  admFeatures.features.forEach((d) => {
    const data = admin_index
      .get(d.properties.admin0_name || null)
      .get(d.properties.admin1_name || null)
      .get(d.properties.admin2_name || null);
    d.properties.value = data["value"];
  });

  //   admFeatures.features.forEach((d) => {
  //     const a2_data = index
  //       .get(d.properties.admin0_name)
  //       .get(d.properties.admin1_name)
  //       .get(d.properties.admin2_name);
  //     d.properties.value = a2_data["value"];
  //   });
  // }
  return admFeatures; // Will return either the updated features or undefined if 'country' is not "SSA"
}
```

```{ojs}
admin0_load = { 
  // Admin 2 is a geojson so that initial page load can be faster(not wait for DB setup)
  let geojson = await FileAttachment(
    "atlas-region_admin0_simplified.geojson"
  ).json();
  let a0_names = geojson.features.map((d) => d.properties.admin0_name);
  mutable admin0_names = ["SSA"].concat(a0_names);
  // if (country !== "SSA") {
  //   let filtered = geojson.features.filter(
  //     (d) => d.properties.admin0_name === country
  //   );
  //   geojson.features = filtered;
  // } else {
  //   return geojson;
  // }
  return geojson;

  // let response = await db.query(`
  //   SELECT *
  //   FROM admin0_geom`);
  // let a0_names = response.map((d) => d.admin0_name);
  // mutable admin0_names = ["SSA"].concat(a0_names);
  // let wkb_list = response.map((d) => d.geometry);
  // let data = await response.map(({ geometry, ...rest }) => rest);
  // const features = [];
  // for (let i = 0; i < wkb_list.length; i++) {
  //   const pointer = GEOS.geosGeomFromWKB(wkb_list[i]);
  //   const geojson = await GEOS.geosGeomToGeojson(pointer, GEOS.geos);
  //   geojson.coordinates.forEach((polygon) => {
  //     polygon.forEach((ring) => {
  //       ring.reverse();
  //     });
  //   });
  //   const feature = {
  //     type: "Feature",
  //     geometry: geojson,
  //     properties: data[i]
  //   };
  //   features.push(feature);
  //   GEOS.geos.GEOSGeom_destroy(pointer);
  // }
  // const geojson = {
  //   type: "FeatureCollection",
  //   features: features
  // };
  // return { names: ["SSA"].concat(a0_names), GEOJSON: geojson };
}
```

```{ojs}
admin0_filtered = {
  if (country !== "SSA") {
    let filtered = admin0_load.features.filter((d) => {
      return d.properties.admin0_name === country;
    });
    // Create a new GeoJSON object with the filtered features
    return {
      type: admin0_load.type,
      features: filtered
    };
  } else {
    return admin0_load;
  }
}
```

```{ojs}
admin1 = {
  let admin1_query;
  if (country === "SSA" && admin_aggregationLevel === "admin1_name") {
    admin1_query = ``;
  } else if (
    admin_aggregationLevel === "admin1_name" ||
    admin_aggregationLevel === "admin2_name"
  ) {
    admin1_query = `WHERE admin0_name = '${country}'`;
  } else {
    admin1_query = `WHERE admin1_name = ''`; // This will always return empty, so response will be empty geojson
  }

  let response = await geo_db.query(`
    SELECT *
    FROM admin1_geom
    ${admin1_query}`);
  let a1_names = response.map((d) => d.admin1_name);
  mutable admin1_names = ["Full Country"].concat(a1_names);
  let wkb_list = response.map((d) => d.geometry);
  let data = await response.map(({ geometry, ...rest }) => rest);
  const features = [];
  for (let i = 0; i < wkb_list.length; i++) {
    const pointer = GEOS.geosGeomFromWKB(wkb_list[i]);
    let geojson = await GEOS.geosGeomToGeojson(pointer, GEOS.geos);
    geojson = turfRewind(geojson, { reverse: true });
    const feature = {
      type: "Feature",
      geometry: geojson,
      properties: data[i]
    };
    features.push(feature);
    GEOS.geos.GEOSGeom_destroy(pointer);
  }
  const geojson = {
    type: "FeatureCollection",
    features: features
  };
  // return { names: ["Full Country"].concat(a1_names), GEOJSON: geojson };
  return geojson;
}
```

```{ojs}
admin2 = {
  let admin2_query;
  if (admin2_sel !== "Full Region") {
    admin2_query = `WHERE admin0_name = '${country}' and admin1_name = '${admin1_sel}'`; // and admin2_name = '${admin2_sel}'
  } else if (
    admin2_sel === "Full Region" &&
    admin1_sel !== "Full Country" &&
    admin_aggregationLevel === "admin2_name"
  ) {
    admin2_query = `WHERE admin0_name = '${country}' and admin1_name = '${admin1_sel}'`;
  } else if (
    admin1_sel === "Full Country" &&
    country !== "SSA" &&
    admin_aggregationLevel === "admin2_name"
  ) {
    admin2_query = `WHERE admin0_name = '${country}'`;
  } else if (country === "SSA" && admin_aggregationLevel === "admin2_name") {
    admin2_query = ``;
  } else {
    admin2_query = `where admin2_name = ''`;
  }

  let response = await geo_db.query(`
    SELECT *
    FROM admin2_geom
    ${admin2_query}`); // WHERE admin0_name = '${country}' AND admin1_name = '${admin1_sel}'`);

  //// THIS IS WHRE YOU ARE AT>>>
  let wkb_list = response.map((d) => d.geometry);
  let data = await response.map(({ geometry, ...rest }) => rest);
  const features = [];
  for (let i = 0; i < wkb_list.length; i++) {
    const pointer = GEOS.geosGeomFromWKB(wkb_list[i]);
    let geojson = await GEOS.geosGeomToGeojson(pointer, GEOS.geos);
    geojson = turfRewind(geojson, { reverse: true });
    const feature = {
      type: "Feature",
      geometry: geojson,
      properties: data[i]
    };
    features.push(feature);
    GEOS.geos.GEOSGeom_destroy(pointer);
  }
  const geojson = {
    type: "FeatureCollection",
    features: features
  };
  // return { names: ["Full Region"].concat(a2_names), GEOJSON: geojson };
  return geojson;
}
```

```{ojs}
append_a2Names = {
  let response = await geo_db.query(`
    SELECT admin2_name
    FROM admin2_geom
    where admin0_name = '${country}' and admin1_name = '${admin1_sel}'`); // WHERE admin0_name = '${country}' AND admin1_name = '${admin1_sel}'`);
  //// THIS IS WHRE YOU ARE AT>>>
  let a2_names = response.map((d) => d.admin2_name);
  mutable admin2_names = ["Full Region"].concat(a2_names);
  return a2_names;
}
```

```{ojs}
md`### Geography Selectors`;
```

```{ojs}
mutable admin0_names = ["SSA"]
```

```{ojs}
mutable admin1_names = ["Full Country"]
```

```{ojs}
mutable admin2_names = ["Full Region"]
```

```{ojs}
viewof country = {
  const country = Inputs.select(admin0_names, {
    label: "Select Country"
  });
  return country;
}
```

```{ojs}
viewof admin1_sel = Inputs.select(admin1_names, { label: "admin1" })
```

```{ojs}
viewof admin2_sel = Inputs.select(admin2_names, { label: "admin2" })
```

```{ojs}
md`## Selector Forms`;
```

```{ojs}
md`### Hazard`;
```

```{ojs}
viewof hazard_sel = Inputs.select(
  // Inputs.select(
  //   new Map(
  //     DataSelector_form.hazardGroup_form.hazard_sel.map((value) => [
  //       hazard_dict[value].name,
  //       value
  //     ])
  //   ),
  //   { label: "Hazard" }
  // ),
  new Map(Object.entries(hazard_dict).map(([key, value]) => [value.name, key])),
  { label: "Hazard" } //, format: ([name]) => `${name}`
)
```

```{ojs}
viewof time_sel = Inputs.select(
  new Map([
    ["Baseline", "historic"],
    ["2040", "2021_2040"],
    ["2060", "2041_2060"]
  ]),
  { label: "Time Period", value: "historic" } //, format: ([name]) => `${name}`
)
```

```{ojs}
viewof ssp_sel = {
  const choices = time_sel === "historic" ? ["Historic"] : ["SSP245", "SSP585"];
  return Inputs.select(choices, { label: "Scenario" });
}
```

```{ojs}
md`### Adaptive Capacity`;
```

```{ojs}
viewof ac_cat = Inputs.select(["Education", "Poverty", "Gender"], {
  // value: "Poverty",
  label: "Adaptive Capacity"
})
```

```{ojs}
viewof ac_subcat = {
  let subcats;
  if (ac_cat === "Gender") {
    subcats = new Map(
      Object.entries(vulnerability_dict["gender"]).map(([key, value]) => [
        value,
        key
      ])
    );
  } else if (ac_cat === "Poverty") {
    subcats = new Map(
      Object.entries(vulnerability_dict["poverty"]).map(([key, value]) => [
        value,
        key
      ])
    );
  } else {
    subcats = [];
  }
  return Inputs.select(subcats, {
    label: `${ac_cat} Category`
  });
}
```

```{ojs}
md`## Exposure`;
```

```{ojs}
viewof exposure_cat = Inputs.select(["Crop", "Livestock", "Population"], {
  value: "Crop",
  label: "Exposure Category"
})
```

```{ojs}
commodities = new Object({
  Crop: [
    "wheat",
    "rice",
    "maize",
    "barley",
    "pearl millet",
    "small millet",
    "sorghum",
    "potato",
    "sweet potato",
    "yams",
    "cassava",
    "bean",
    "chickpea",
    "cowpea",
    "pigeonpea",
    "lentil",
    "soybean",
    "groundnut",
    "coconut",
    "oilpalm",
    "sunflower",
    "rapeseed",
    "sesameseed",
    "sugarcane",
    "sugarbeet",
    "cotton",
    "arabica coffee",
    "robusta coffee",
    "cocoa",
    "tea",
    "tobacco",
    "banana",
    "plantain",
  ],
  Livestock: [
    "cattle_tropical",
    "poultry_tropical",
    "pigs_tropical",
    "sheep_tropical",
    "goats_tropical",
    "cattle_highland",
    "poultry_highland",
    "pigs_highland",
    "sheep_highland",
    "goats_highland",
  ],
});
```

```{ojs}
viewof exposure_subCat = {
  let title;
  let selections;
  if (exposure_cat === "Population") {
    title = "Population Group";
    selections = new Map([
      ["Total Population", "total_pop"],
      ["Rural Population", "rural_pop"],
      ["Urban Population", "urban_pop"]
    ]);
  } else {
    title = "Commodity";
    selections = commodities[exposure_cat];
  }

  return Inputs.select(selections, {
    label: title
  });
}
```

```{ojs}
exposure_var_choices = {
  let choices;
  if (exposure_cat === "Population") {
    choices = [
      "total_pop",
      "rural_pop",
      "urban_pop"
      // { name: "Total Population", variable: "total_pop" },
      // { name: "Rural Population", variable: "rural_pop" },
      // { name: "Urban Population", variable: "urban_pop" }
    ]; //add density to raster
  } else if (exposure_cat === "Crop") {
    choices = [
      'vop',
      'ha'
      // { name: "Value of Production", variable: "vop" },
      // { name: "Harvested Area", variable: "ha" }
    ];
  } else {
    choices = [
      'vop',
      'number'
      // { name: "Value of Production", variable: "vop" },
      // { name: "Number of Animals", variable: "number" }
    ];
  }
  return choices;
}
```

```{ojs}
viewof exposure_var = {
  return Inputs.select(exposure_var_choices, {
    label: "Variable",
    format: (t) => _lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.options[t])
  });
}
```

```{ojs}
md`## Map Setup`;
```

```{ojs}
md`### D3 map`;
```

```{ojs}
map = () => {
  const width = 950;
  const height = 600;

  let minValue;
  let maxValue;

  if (var_unit["category"] === "index") {
    minValue = 0;
    maxValue = 1;
  } else {
    minValue = d3.min(adminLevel_spatial.features, (d) => d.properties.value);
    maxValue = d3.max(adminLevel_spatial.features, (d) => d.properties.value);
  }

  d3.selectAll(".mapTip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip mapTip")
    .style("position", "absolute");

  let color;
  if (atlas_cat === "Hazard") {
    color = d3.scaleThreshold(
      hazard_dict[hazard_sel]["thresholds"],
      hazard_dict[hazard_sel]["colours"],
    );
  } else if (
    atlas_cat === "Exposure" &&
    (exposure_cat === "Crop" || exposure_cat === "Livestock")
  ) {
    color = function (v) {
      let nonZero_min = (minValue = d3.min(adminLevel_spatial.features, (d) =>
        d.properties.value && d.properties.value !== 0
          ? d.properties.value
          : Infinity,
      ));
      let d3color = d3
        .scaleLog()
        .domain([nonZero_min, maxValue])
        .range(["#F7D732", "#216729"]);
      return v === 0 ? "lightgrey" : d3color(v);
    };
  } else {
    // Add a ability to flip color
    let color_hex =
      atlas_cat === "Vulnerability" && ac_cat === "Poverty"
        ? ["#216729", "#F7D732"]
        : ["#F7D732", "#216729"];
    color = d3.scaleLinear().domain([minValue, maxValue]).range(color_hex);
  }

  const projection = d3
    .geoAzimuthalEqualArea()
    .fitSize([width, 600], adminLevel_spatial);

  const path = d3.geoPath(projection);

  const padding = 75;

  const svg = d3
    .create("svg")
    .attr("width", width + 50)
    .attr("viewBox", [0, -padding, width, 600 + padding])
    .style("background", "lightblue") // set the background color
    .style("cursor", "grab");
  // .style("border", "1px solid black");

  const map = svg
    .append("g")
    .selectAll("path")
    .data(adminLevel_spatial.features)
    .join("path")
    .attr("fill", (d) => color(d.properties.value))
    .attr("stroke", "#fff")
    .attr("stroke-width", "1")
    .attr("stroke-linejoin", "round")
    .attr("d", path);

  map
    .on("mouseover", (event, d) => {
      d3.select(event.currentTarget).style("stroke", "black").raise();
    })
    .on("mousemove", (event, d) => {
      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .style("display", "block")
        .html(
          `${make_tooltip_admin(d.properties)}<br>${_lang(nbText.ViewExplore.exploreMap.value)}: ${format_val(
            d.properties.value,
            var_unit["category"],
          )} (${var_unit.label})`,
        );
    })
    .on("mouseout", function (event) {
      d3.select(".mapTip").style("display", "none");
      d3.select(event.currentTarget).style("stroke", "#fff");
    });

  // Section to add highlights for selected country when admin at limit
  let selectedArea;
  if (admin_aggregationLevel === "admin0_name" && country !== "SSA") {
    selectedArea = adminLevel_spatial.features.filter(
      (d) => d.properties.admin0_name === country,
    );
  } else if (
    admin_aggregationLevel === "admin1_name" &&
    admin1_sel !== "Full Country"
  ) {
    selectedArea = adminLevel_spatial.features.filter(
      (d) => d.properties.admin1_name === admin1_sel,
    );
  } else if (admin2_sel !== "Full Region") {
    selectedArea = adminLevel_spatial.features.filter(
      (d) => d.properties.admin2_name === admin2_sel,
    );
  }
  let outline;
  if (selectedArea) {
    outline = svg
      .append("path")
      .data(selectedArea)
      .attr("fill", "none")
      .attr("stroke", "red")
      .attr("stroke-width", "2")
      .attr("stroke-linejoin", "round")
      .attr("d", path);
  }

  let legend_bg = svg // add a white bg box for the legend so it doesn't overlap on zoom
    .append("g")
    .append("rect")
    .attr("width", width)
    .attr("height", 70)
    .attr("y", -75)
    .attr("fill", "white")
    .attr("opacity", 0.9);

  // createLinearLegend(svg, minValue, maxValue, width, height, color);
  if (atlas_cat === "Hazard") {
    createThresholdLegend(
      svg,
      hazard_dict[hazard_sel]["thresholds"],
      hazard_dict[hazard_sel]["colours"],
      height,
      format_val,
    );
  } else {
    createLinearLegend(svg, minValue, maxValue, width, height, color);
  }

  svg.call(
    d3
      .zoom()
      .extent([
        [0, 0],
        [width, height],
      ])
      .scaleExtent([1, 8])
      .on("zoom", zoomed),
  );

  const resetButton = svg
    .append("foreignObject")
    .attr("width", 150)
    .attr("height", 50)
    .attr("x", 750)
    .attr("y", -65)
    .html(
      `<button id=reset_button style="color: black;">${_lang(nbText.ViewExplore.exploreMap.resetBtn)}</button>`,
    );

  resetButton.select("button").on("click", () => {
    svg
      .transition()
      .duration(750)
      .call(
        d3
          .zoom()
          .extent([
            [0, 0],
            [width, height],
          ])
          .scaleExtent([1, 8])
          .on("zoom", zoomed).transform,
        d3.zoomIdentity,
      );
  });

  return svg.node();

  function zoomed({ transform }) {
    map.attr("transform", transform);
    map.style("stroke-width", 1 / transform.k);
    if (outline) {
      outline.attr("transform", transform);
      outline.style("stroke-width", 1 / transform.k);
    }
  }

  function make_tooltip_admin(d) {
    let admin_text;
    if (d.admin1_name === undefined) {
      admin_text = `${_lang(nbText.general.adminlevels.admin0_name)}: ${_lang(nbText.general.adminNames[d.admin0_name])}`;
    } else if (d.admin1_name !== undefined && d.admin2_name === undefined) {
      admin_text = `${_lang(nbText.general.adminlevels.admin0_name)}: ${d.admin0_name}<br>${_lang(nbText.general.adminlevels.admin1_name)}: ${d.admin1_name}`;
    } else if (d.admin1_name !== undefined && d.admin2_name !== undefined) {
      admin_text = `${_lang(nbText.general.adminlevels.admin0_name)}: ${d.admin0_name}<br>${_lang(nbText.general.adminlevels.admin1_name)}: ${d.admin1_name}<br>${_lang(nbText.general.adminlevels.admin2_name)}: ${d.admin2_name}`;
    }
    return admin_text;
  }

  function createLinearLegend(svg, minValue, maxValue, width, height, color) {
    const padding = 65;
    const defs = svg.append("defs");
    const linearGradient = defs
      .append("linearGradient")
      .attr("id", "linear-gradient");

    linearGradient
      .selectAll("stop")
      .data([minValue, maxValue])
      .join("stop")
      .attr("offset", (d, i, n) => `${(100 * i) / (n.length - 1)}%`)
      .attr("stop-color", color);

    const legend = svg
      .append("g")
      .attr(
        "transform",
        `translate(${width - 700}, ${height - padding - 575})`,
      );

    legend
      .append("rect")
      .attr("transform", "translate(0, -10)")
      .attr("width", 250)
      .attr("height", 10)
      .style("fill", "url(#linear-gradient)");

    const midValue = (minValue + maxValue) / 2;

    legend
      .append("g")
      .call(
        d3
          .axisBottom(
            d3.scaleLinear().range([0, 250]).domain([minValue, maxValue]),
          )
          .tickValues([minValue, midValue, maxValue])
          .tickFormat(
            (v) =>
              `${format_val(v, var_unit["category"])} ${var_unit.label === "%" ? "" : var_unit.label}`,
          ),
      )
      .select(".domain");
  }

  function createThresholdLegend(svg, thresholds, colors, height, format_val) {
    const padding = 65;
    const legendWidth = 230;
    const bandWidth = legendWidth / (thresholds.length - 1);
    const legend = svg
      .append("g")
      .attr(
        "transform",
        `translate(${width - 700}, ${height - padding - 575})`,
      );

    // Append color bands to legend
    const labels = ["low", "moderate", "severe", "extreme", "Vextreme"];

    colors.forEach((threshold, index) => {
      legend
        .append("rect")
        .attr("x", index * bandWidth)
        // .attr("y", -10)
        .attr("width", bandWidth)
        .attr("height", 10)
        .style("fill", colors[index]);
      // Add label
      legend
        .append("text")
        .attr("x", index * bandWidth + bandWidth / 2)
        .attr("y", -15) // Adjust this value as needed for label positioning
        .style("text-anchor", "middle")
        .text(_lang(nbText.general.levels[labels[index]]))
        .attr("font-size", "12px")
        .attr("fill", "black"); // Set the color of the label text
    });
  }
};
```

```{ojs}
md`## Definition boxes`;
```

```{ojs}
create_definitions = (category) => {
  let def_text = _lang(definitionText[category].text);
  return html`<details style="padding: 0, 0 ;border-radius:5px;background:none;max-width:600px">
  <summary style="cursor:pointer">${_lang(definitionText[category].title)}</summary>
  <div style="margin:.5em 0;border-top:1px dashed #888">
${md`${def_text}`}
<div></details>`;
};
```

```{ojs}
md`## Plot Functions`;
```

```{ojs}
function createPlot() {
  if (atlas_cat === "Exposure") {
    if (exposure_cat.includes("Livestock") || exposure_cat.includes("Crop")) {
      return exposure_treeplot();
    } else if (exposure_cat === "Population") {
      return population_stackbars();
    }
  } else if (atlas_cat === "Hazard") {
    return hazard_stackBar(hazard_sel);
  } else if (atlas_cat === "Vulnerability") {
    return parallelCoordinatesScatterPlot();
  }
}
```

```{ojs}
createTable = () => {
  let table = Inputs.table(data_to_visualise, {
    rows: 25,
    maxWidth: "1000px",
  });
  const style = document.createElement("style");
  style.innerHTML = `
    .exploreTable th {
      background-color: lightgrey !important;
    }
    .exploreTable tr:nth-child(odd) {
      background: #f2f2f2!important;
    }
    .exploreTable td {
      padding-left: 15px !important;
    }
  `;
  table.classList.add("exploreTable");
  table.appendChild(style);

  const checkboxes = table.querySelectorAll('table input[type="checkbox"]');

  // Remove all checkboxes
  checkboxes.forEach(function (checkbox) {
    checkbox.parentNode.removeChild(checkbox);
  });

  return table;
};
```

```{ojs}
exposure_treeplot = async () => {
  let admin_query;
  if (country === "SSA") {
    admin_query = `"admin1_name" IS NULL`;
  } else if (country !== "SSA" && admin1_sel === "Full Country") {
    admin_query = `"admin0_name" LIKE '${country}' AND "admin1_name" IS NOT NULL AND "admin2_name" IS NULL`;
  } else if (country !== "SSA" && admin1_sel !== "Full Country") {
    admin_query = `"admin0_name" LIKE '${country}' AND "admin1_name" LIKE '${admin1_sel}' AND "admin1_name" IS NOT NULL AND "admin2_name" IS NOT NULL`;
  }
  let formatTree = exposure_var === "number" ? formatBigNums : formatDollar;

  let translateCrop = (d) => {
    return (
      _lang(nbText.ViewExplore.exposureTreemap.cropGroups[d]) ||
      _lang(nbText.general.commodities[d]) ||
      d
    );
  };

  const data_unformatted = await db.query(`
SELECT crop, SUM(value) as VOP, FROM Exposure
${plotQuery_admin}
AND "exposure" = '${exposure_var}'
AND "crop" NOT IN ('total_highland', 'total_tropical')
and "group" = '${exposure_cat.toLocaleLowerCase()}'
GROUP BY crop`);

  d3.selectAll(".plotTooltip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip TreeTip")
    .style("position", "absolute");

  const data = new Object({
    name: "total",
    children: Object.entries(crop_groups).map(([groupName, crops]) => ({
      name: groupName,
      children: crops.map((cropName) => {
        const cropData = data_unformatted.find((d) => d.crop === cropName);
        return { name: cropName, value: cropData ? cropData.VOP : 0 };
      }),
    })),
  });

  const width = 1000;
  const height = 600;

  // This custom tiling function adapts the built-in binary tiling function
  // for the appropriate aspect ratio when the treemap is zoomed-in.
  function tile(node, x0, y0, x1, y1) {
    d3.treemapBinary(node, 0, 0, width, height);
    for (const child of node.children) {
      child.x0 = x0 + (child.x0 / width) * (x1 - x0);
      child.x1 = x0 + (child.x1 / width) * (x1 - x0);
      child.y0 = y0 + (child.y0 / height) * (y1 - y0);
      child.y1 = y0 + (child.y1 / height) * (y1 - y0);
    }
  }

  // Compute the layout.
  const hierarchy = d3
    .hierarchy(data)
    .sum((d) => d.value)
    .sort((a, b) => b.value - a.value);
  const root = d3.treemap().tile(tile)(hierarchy);

  const smallest_crop = d3.min(data_unformatted, (d) => d.VOP);
  const largest_group = d3.max(hierarchy.children.map((d) => d.value));

  const colorScale = d3
    .scaleLinear()
    .domain([smallest_crop, largest_group])
    .range(["#F7D732", "#71913D"]);

  // Create the scales.
  const x = d3.scaleLinear().rangeRound([0, width]);
  const y = d3.scaleLinear().rangeRound([0, height]);

  // Formatting utilities.
  const format = d3.format(",d");
  const name = (d) => d.data.name;

  // Create the SVG container.
  const svg = d3
    // .select(container)
    .create("svg")
    // .append("svg")
    .attr("viewBox", [0.5, -50.5, width, height + 50])
    .attr("width", width)
    .attr("height", height + 50)
    .attr("style", "max-width: 100%; height: auto;");

  // Display the root.
  let group = svg.append("g").call(render, root);

  function render(group, root) {
    const node = group
      .selectAll("g")
      .data(root.children.concat(root))
      .join("g");

    node
      .filter((d) => (d === root ? d.parent : d.children))
      .attr("cursor", "pointer")
      .on("click", (event, d) => (d === root ? zoomout(root) : zoomin(d)));

    // node.append("title").text((d) => `${name(d)}\n${formatTree(d.value)}`);
    node
      .on("mousemove", (event, d) => {
        let tipData = d.data;
        tooltip
          .style("top", event.pageY - 10 + "px")
          .style("left", event.pageX + 10 + "px")
          // .transition()
          // .duration(200)
          .style("opacity", 1)
          .style("display", "block")
          .html(`${translateCrop(name(d))} - ${formatTree(d.value)}`);
      })
      .on("mouseout", function (event) {
        d3.select(".plotTooltip")
          // .transition()
          // .duration(200)
          // .style("opacity", 0)
          .style("display", "none");
      });

    const rects = node
      .append("rect")
      .attr("id", (d) => (d.leafUid = DOM.uid("leaf")).id)
      .attr("fill", (d) =>
        d === root
          ? "#e6e6e6"
          : d.children
            ? colorScale(d.value)
            : colorScale(d.value),
      )
      .attr("stroke", "#e6e6e6");

    node
      .append("clipPath")
      .attr("id", (d) => (d.clipUid = DOM.uid("clip")).id)
      .append("use")
      .attr("xlink:href", (d) => d.leafUid.href);

    let text = node
      .append("text")
      .attr("clip-path", (d) => d.clipUid)
      // .attr("font-weight", (d) => (d === root ? "bold" : null))
      .attr("font-size", (d) =>
        d === root ? "20px" : d.children ? "15px" : "14px",
      )
      .selectAll("tspan")
      .data((d) =>
        (d === root
          ? (
              translateCrop(name(d)) +
              " " +
              _lang(
                nbText.ViewExplore.selectors.visualiseVars.exposure
                  .exposureVariable.options[exposure_var],
              ) +
              ":"
            ).split(/(?=[A-Z][&][^A-Z])/g)
          : // : d.data.name.split(/(?=[A-Z][^A-Z])/g)
            translateCrop(name(d)).split(/(?=[A-Z][^A-Z])/g)
        ) //.concat(d.value)
          .concat(formatTree(d.value)),
      )
      .join("tspan")
      .attr("x", 3)
      .attr(
        "y",
        (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`,
      )
      .attr("fill-opacity", (d, i, nodes) =>
        i === nodes.length - 1 ? 0.7 : null,
      )
      .attr("font-weight", (d, i, nodes) =>
        i === nodes.length - 1 ? "normal" : null,
      )
      .text((d) => d);

    group.call(position, root);
  }

  function position(group, root) {
    group
      .selectAll("g")
      .attr("transform", (d) =>
        d === root ? `translate(0,-55)` : `translate(${x(d.x0)},${y(d.y0)})`,
      )
      .selectAll("rect")
      .attr("width", (d) => (d === root ? width : x(d.x1) - x(d.x0)))
      .attr("height", (d) => (d === root ? 55 : y(d.y1) - y(d.y0)));

    group.selectAll("text").attr("opacity", (d) => {
      const rect_width = x(d.x1) - x(d.x0);
      const rect_height = y(d.y1) - y(d.y0);
      return rect_height < 70 || rect_width < 70 ? 0 : 1;
    });
  }

  // When zooming in, draw the new nodes on top, and fade them in.
  function zoomin(d) {
    const group0 = group.attr("pointer-events", "none");
    const group1 = (group = svg.append("g").call(render, d));

    x.domain([d.x0, d.x1]);
    y.domain([d.y0, d.y1]);

    svg
      .transition()
      .duration(750)
      .call((t) => group0.transition(t).remove().call(position, d.parent))
      .call((t) =>
        group1
          .transition(t)
          .attrTween("opacity", () => d3.interpolate(0, 1))
          .call(position, d),
      );
  }

  // When zooming out, draw the old nodes on top, and fade them out.
  function zoomout(d) {
    const group0 = group.attr("pointer-events", "none");
    const group1 = (group = svg.insert("g", "*").call(render, d.parent));

    x.domain([d.parent.x0, d.parent.x1]);
    y.domain([d.parent.y0, d.parent.y1]);

    svg
      .transition()
      .duration(750)
      .call((t) =>
        group0
          .transition(t)
          .remove()
          .attrTween("opacity", () => d3.interpolate(1, 0))
          .call(position, d),
      )
      .call((t) => group1.transition(t).call(position, d.parent));
  }

  return svg.node();
};
```

```{ojs}
hazard_stackBar = async (hazard) => {
  // const data = bar_data[hazard];
  const data = classifyAndCount(
    await db.query(
      `SELECT * From Hazard ${mapDataQuery_admin} and "hazard" = '${hazard}' and "timeframe" in ('${DataSelector_form.hazardGroup_form.timeperiod_sel.join(
        "', '",
      )}')`,
    ),
  )[hazard];
  const colors = hazard_dict[hazard].colours;

  const labels = ["low", "moderate", "severe", "extreme", "Vextreme"].slice(
    0,
    colors.length,
  );

  const transformedData = [];
  for (const scenario in data) {
    for (const period in data[scenario]) {
      transformedData.push({
        scenario,
        period,
        values: data[scenario][period],
      });
    }
  }

  const width = 750;
  const height = 600;
  const margin = { top: 30, right: 10, bottom: 15, left: 40 };

  // SVG Container
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, width, height])
    .attr("width", width)
    .attr("height", height);

  d3.selectAll(".plotTooltip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip barTip")
    .style("position", "absolute");

  // Set up x and y scales
  const sortOrder = [
    "historic_historic",
    "ssp245_2021_2040",
    "ssp585_2021_2040",
    "ssp245_2041_2060",
    "ssp585_2041_2060",
  ];
  const x = d3
    .scaleBand()
    // .domain(transformedData.map((d) => `${d.scenario}_${d.period}`))
    .domain(
      sortOrder.filter((d) =>
        transformedData.some((e) => e.scenario + "_" + e.period === d),
      ),
    )
    .range([margin.left, width])
    .padding(0.1);

  const y = d3
    .scaleLinear()
    .domain([0, d3.max(transformedData, (d) => d3.sum(d.values))])
    .nice()
    .range([height - margin.bottom, margin.top]);

  // Add x and y axes
  svg
    .append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(
      d3
        .axisBottom(x)
        .tickSize(0)
        .tickFormat((d) => {
          return d === "historic_historic"
            ? _lang(
                nbText.selectVars.forms.Hazard.selectors.period.options
                  .historic,
              )
            : `${d.split("_")[2]} (${d.split("_")[0].toUpperCase()})`;
        }),
    );

  svg
    .append("g")
    .attr("class", "y-axis")
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(y).tickSize(0))
    .selectAll(".tick text") // select the text elements of the ticks
    .attr("dy", "0.5em")
    .style("text-anchor", "end");

  // Create stacks
  const stack = d3
    .stack()
    .keys(d3.range(transformedData[0].values.length))
    .value((d, key) => d.values[key]);

  const series = stack(transformedData);

  // Add bars
  const bars = svg
    .append("g")
    .selectAll("g")
    .data(series)
    .join("g")
    .attr("fill", (d, i) => colors[i])
    .selectAll("rect")
    // .data((d) => d)
    .data((d) => d.map((value) => ({ ...value, index: d.index })))
    .join("rect")
    .attr("x", (d) => x(`${d.data.scenario}_${d.data.period}`))
    .attr("y", (d) => y(d[1]))
    .attr("height", (d) => y(d[0]) - y(d[1]))
    .attr("width", x.bandwidth());

  bars
    .on("mouseover", (event, d) => {
      d3.select(event.currentTarget).style("stroke", "black").raise();
    })
    .on("mousemove", (event, d) => {
      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .style("display", "block")
        .html(
          `<b>${_lang(nbText.general.hazards[hazard])}</b> <br> ${_lang(nbText.ViewExplore.hazardBars.lvl)}: ${_lang(
            nbText.general.levels[labels[d.index]],
          )} <br> ${_lang(nbText.ViewExplore.hazardBars.numAreas)}: ${d.data.values[d.index]}`,
        );
    })
    .on("mouseout", function (event) {
      d3.select(".plotTooltip").style("display", "none");
      d3.select(event.currentTarget).style("stroke", "none");
    });
  // Add y axis title
  svg
    .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 0)
    .attr("x", 0 - height / 2)
    .attr("dy", "1em")
    .style("fontSize", "12px")
    .style("text-anchor", "middle")
    .text(_lang(nbText.ViewExplore.hazardBars.yaxis));

  // append legend
  const Legendpadding = 65;
  const legendWidth = 200;
  const bandWidth = legendWidth / (hazard_dict[hazard].thresholds.length - 1);
  const legend = svg
    .append("g")
    .attr("transform", `translate(${margin.left + 11}, ${margin.top - 5})`);

  colors.forEach((threshold, index) => {
    legend
      .append("rect")
      .attr("x", index * bandWidth)
      .attr("y", -10)
      .attr("width", bandWidth)
      .attr("height", 10)
      .style("fill", colors[index]);
    // Add label
    legend
      .append("text")
      .attr("x", index * bandWidth + bandWidth / 2)
      .attr("y", -15) // Adjust this value as needed for label positioning
      .style("text-anchor", "middle")
      .text(_lang(nbText.general.levels[labels[index]]))
      .attr("font-size", "12px")
      .attr("fill", "black"); // Set the color of the label text
  });

  return svg.node();
};
```

```{ojs}
function classifyAndCount(data) {
  const result = {};

  // Helper function to classify a number based on thresholds
  function classifyNumber(number, thresholds) {
    for (let i = 0; i < thresholds.length; i++) {
      if (number < thresholds[i]) {
        return i;
      }
    }
    return thresholds.length;
  }

  data.forEach((row) => {
    const { admin0_name, scenario, timeframe, hazard, value } = row;
    const thresholds = hazard_dict[hazard].thresholds;
    if (!thresholds) {
      console.error(`No thresholds found for hazard: ${hazard}`);
      return;
    }
    const classification = classifyNumber(value, thresholds);

    if (!result[hazard]) {
      result[hazard] = {};
    }
    if (!result[hazard][scenario]) {
      result[hazard][scenario] = {};
    }
    if (!result[hazard][scenario][timeframe]) {
      result[hazard][scenario][timeframe] = Array(thresholds.length + 1).fill(
        0,
      );
    }

    result[hazard][scenario][timeframe][classification]++;
  });

  return result;
}
```

```{ojs}
population_stackbars = async () => {
  const width = 750;
  const height = 560;
  const margin = { top: 0, right: 10, bottom: 0, left: 120 };
  const barHeight = 30; // Height of each bar
  // Calculate the total height needed for all bars

  const data = await db.query(`
    SELECT admin0_name, admin1_name, admin2_name, rural_pop, urban_pop, total_pop 
    FROM exposurePopulation 
    ${plotQuery_admin}`);

  data.sort((a, b) => b.total_pop - a.total_pop);

  const totalHeight = data.length * barHeight;
  // SVG Container
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, width + margin.left + margin.right, totalHeight])
    .attr("width", width + margin.left + margin.right)
    .attr("height", totalHeight + margin.top + margin.bottom);

  d3.selectAll(".plotTooltip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip barTip")
    .style("position", "absolute");
  const keys = ["rural_pop", "urban_pop"];
  const stackedData = d3
    .stack()
    .keys(keys)
    .value((d, key) => d[key])(data);

  // Set up scales
  const x = d3
    .scaleLinear()
    .domain([0, d3.max(data, (d) => d.total_pop)])
    .nice()
    .range([margin.left, width - margin.right]);

  const y = d3
    .scaleBand()
    .domain(data.map((d) => d[admin_aggregationLevel]))
    .range([margin.top, totalHeight])
    .padding(0.1);

  const color = d3.scaleOrdinal().domain(keys).range(["#216729", "#F7D732"]);

  // Draw the bars
  const bars = svg
    .append("g")
    .selectAll("g")
    .data(stackedData)
    .join("g")
    .attr("fill", (d) => color(d.key))
    .selectAll("rect")
    .data((d) => d)
    .join("rect")
    .attr("x", (d) => x(d[0]))
    .attr("y", (d) => y(d.data[admin_aggregationLevel]))
    .attr("height", y.bandwidth())
    .attr("width", (d) => x(d[1]) - x(d[0]));

  bars
    .on("mouseover", (event, d) => {
      d3.select(event.currentTarget).style("stroke", "black").raise();
    })
    .on("mousemove", (event, d) => {
      const key = event.target.parentNode.__data__.key;

      tooltip
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1)
        .style("display", "block")
        .html(
          `${
            d.data[admin_aggregationLevel]
          } <br> ${_lang(nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable.options[key])}: ${format_val(d[1] - d[0], "total")}`,
        );
    })
    .on("mouseout", function (event) {
      d3.select(".plotTooltip").style("display", "none");
      d3.select(event.currentTarget).style("stroke", "none");
    });

  // Add the Y axis
  svg
    .append("g")
    .attr("transform", `translate(${margin.left}, 0)`)
    .call(d3.axisLeft(y));

  const legendSvg = d3
    .create("svg")
    .attr("width", width + 50)
    .attr("height", 75);

  // Add legend to the new SVG
  const legend = legendSvg
    .append("g")
    .attr("class", "legend")
    .selectAll("g")
    .data(keys)
    .join("g")
    .attr("transform", (d, i) => `translate(10, ${i * 20})`);

  legend
    .append("rect")
    .attr("width", 18)
    .attr("height", 18)
    .attr("fill", color);

  legend
    .append("text")
    .attr("x", 24)
    .attr("y", 9)
    .attr("dy", "0.35em")
    .text((d) =>
      _lang(
        nbText.ViewExplore.selectors.visualiseVars.exposure.exposureVariable
          .options[d],
      ),
    );
  // .text((d) => (d === "rural_pop" ? "Rural Population" : "Urban Population"));

  // Add the X axis
  legendSvg
    .append("g")
    .attr("transform", `translate(0, 75)`)
    .call(d3.axisTop(x).ticks(5));

  const legendContainer = html`<div style="width: 100%;">${legendSvg.node()}</div>`;
  const scrollableContainer = html`<div style="overflow-y: auto; width: 100%; height: ${
    height + margin.top + margin.bottom
  }px;padding=0px; margin=0px;">${svg.node()}</div>`;

  const container = html`<div>${legendContainer}${scrollableContainer}</div>`;
  return container;
};
```

```{ojs}
function format_slopeData(data) {
  const order = ["historic", "2021_2040", "2041_2060"];

  const admin_grouped = Array.from(
    d3.group(data, (d) => d["hazard"]),
    ([admin_name, values]) => {
      values.sort(
        (a, b) => order.indexOf(a.timeframe) - order.indexOf(b.timeframe),
      );
      return {
        admin_name,
        values: values.map(({ timeframe, scenario, value, percentChange }) => ({
          timeframe,
          scenario,
          value,
          percentChange,
        })),
      };
    },
  );
  return admin_grouped;
}
```

```{ojs}
calculatePercentChange = (data) => {
  const baseline = {};

  // Find historic baseline values
  for (const row of data) {
    if (row.scenario === "historic" && row.timeframe === "historic") {
      baseline[row.hazard] = row.admin_mean;
    }
  }

  const results = [];
  for (const row of data) {
    const hazard = row.hazard;
    const scenario = row.scenario;
    const timeframe = row.timeframe;
    const value = row.admin_mean;
    const baselineValue = baseline[hazard];

    // Check if baseline value exists
    if (baselineValue !== undefined && scenario !== "historic") {
      const change = value - baselineValue;
      const percentChange = (change / baselineValue) * 100;
      results.push({ hazard, scenario, timeframe, value, percentChange });
    } else {
      results.push({ hazard, scenario, timeframe, value, percentChange: null });
    }
  }

  return results;
};
```

```{ojs}
function scaleHazardValue(value, minValue, maxValue) {
  const thresholds = hazard_dict["HSH_max"]["thresholds"];

  // Calculate the range between the minimum and maximum values
  const range = maxValue - minValue;

  // Determine the scale based on thresholds
  if (value <= thresholds[0]) {
    return 1;
  } else if (value <= thresholds[1]) {
    return Math.ceil(
      1 + ((value - thresholds[0]) / (thresholds[1] - thresholds[0])) * 2,
    );
  } else if (value <= thresholds[2]) {
    return Math.ceil(
      4 + ((value - thresholds[1]) / (thresholds[2] - thresholds[1])) * 3,
    );
  } else if (value <= thresholds[3]) {
    return Math.ceil(
      7 + ((value - thresholds[2]) / (thresholds[3] - thresholds[2])) * 3,
    );
  } else {
    return 10;
  }
}
```

```{ojs}
parallelCoordinatesPlot = async () => {
  const margin = { top: 30, right: 80, bottom: 25, left: 40 },
    width = 1200 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;

  let group_query;
  if (
    DataSelector_form.vulnerabilityGroup_form.vulnerability_sel.every(
      (d) => d === "Education",
    )
  ) {
    group_query = `AND "group" = 'education' OR "variable" = 'education'`;
  } else {
    group_query = `AND "group" in (${
      "'" +
      DataSelector_form.vulnerabilityGroup_form.vulnerability_sel
        .join("', '")
        .toLowerCase() +
      "'"
    })`;
  }

  // let selected_country = "";
  let data = await db.query(
    `SELECT "admin0_name", "admin1_name", "admin2_name", "group", "variable", "value"
     FROM Vulnerability 
     ${mapDataQuery_admin}
     AND "variable" != 'GenderEquity_1995.2015'
     ${group_query}`,
  );
  const data_vuln = pivotData(data);
  let means = calculateMeans(data);
  means.country = "Regional Average";

  const color = d3
    .scaleOrdinal()
    .domain(data_vuln.map((d) => d.country))
    .range(d3.schemeCategory10);

  const svg = d3
    .create("svg")
    .attr("id", "VulnerableParallelLine")
    .attr("viewBox", [0, 0, width, height])
    .attr("width", width)
    .attr("height", height);

  const dimensions = Object.keys(data_vuln[0]).filter((d) => d !== "country");
  dimensions.sort();
  const y = {};
  for (const dim of dimensions) {
    let y_extent =
      dim === "education-educationYrs"
        ? // ? d3.extent(data_vuln, (item) => item[dim])
          [0, d3.max(data_vuln, (item) => item[dim])]
        : [0, 1];
    y[dim] = d3
      .scaleLinear()
      .domain(y_extent)
      .range([height - margin.bottom, margin.top]);
  }

  const x = d3
    .scalePoint()
    .domain(dimensions)
    .range([margin.left, width - margin.right]);

  const line = d3
    .line()
    .defined((d) => !isNaN(d[1]))
    .x((d) => x(d[0]))
    .y((d) => y[d[0]](d[1]));

  const tooltip = d3
    .select("body")
    .append("div")
    .style("position", "absolute")
    .style("background-color", "white")
    .style("padding", "5px")
    .style("border", "1px solid black")
    .style("border-radius", "5px")
    .style("opacity", 0);

  let countrylines = svg
    .selectAll(".countryLines")
    .data(data_vuln)
    .enter()
    .append("path")
    .attr("class", "countryLines")
    .attr("d", (d) => line(dimensions.map((p) => [p, d[p]])))
    .style("fill", "none")
    .style(
      "stroke",
      "lightgrey", // (d.country === selected_country ? "green" : "lightgrey") //color(d.country)
    )
    .style("stroke-width", 1.5)
    .style("opacity", 0.2) // (d) => (d.country === selected_country ? 0.9 : 0.2))
    .on("mouseover", function (event, d) {
      // svg.selectAll(".countryLines").style("opacity", 0.1);
      d3.select(this).style("opacity", 1).style("stroke", "#F29D2D");
      tooltip.transition().duration(0).style("opacity", 0.9);
      tooltip
        .html(`${d.country}`)
        .style("left", event.pageX + 10 + "px")
        .style("top", event.pageY - 28 + "px");
    })
    .on("mouseout", function (d) {
      svg
        .selectAll(".countryLines")
        .style("opacity", 0.2) // (d) => (d.country === selected_country ? 0.9 : 0.2));
        .style("stroke", "lightgrey");
      tooltip.transition().duration(500).style("opacity", 0);
    });

  let avg_lines = svg
    .selectAll("avgPath")
    .data(means)
    .enter()
    .append("path")
    .attr("d", (d) => line(dimensions.map((p) => [p, d[p]])))
    .style("fill", "none")
    .style("stroke", "#2E7636")
    .style("stroke-width", 1.5)
    .style("opacity", 1);

  svg
    .selectAll("myAxis")
    .data(dimensions)
    .enter()
    .append("g")
    .attr("transform", (d) => "translate(" + x(d) + ")")
    .attr("pointer-events", "none")
    .each(function (d) {
      d3.select(this).call(d3.axisLeft().scale(y[d]));
    })
    .append("text")
    .style("text-anchor", "middle")
    // .attr("y", 10)
    // .attr("x", 0)
    .attr("y", (d, i) => {
      return i % 2 === 0 ? 10 : height - margin.bottom + 20;
    })
    .text((d) => {
      let split = d.split("-");
      console.log(d);
      // let clean_text = vulnerability_dict[split[0]][split[1]];
      let clean_text = _lang(nbText.general.acVars[split[1]]);
      return clean_text;
    })
    .style("fill", "black")
    .style("font-size", "12px");

  svg
    .selectAll("avgLabel")
    .data(means)
    .enter()
    .append("text")
    .attr("x", width - margin.right) // Align it with the right margin
    .attr("y", (d) =>
      y[dimensions[dimensions.length - 1]](
        d[dimensions[dimensions.length - 1]],
      ),
    )
    .attr("dy", ".35em")
    .attr("text-anchor", "start")
    .style("fill", "#2E7636")
    .selectAll("tspan")
    .data([country, "Average"])
    .enter()
    .append("tspan")
    .attr("x", width - margin.right + 5) // Align both lines with the same x position
    .attr("dy", (d, i) => (i === 0 ? 0 : "1.2em")) // Offset the second line
    .text((d) => d);

  return svg.node();

  function pivotData(data) {
    const pivotedData = {};

    data.forEach((row) => {
      const country = row[admin_aggregationLevel];

      if (!pivotedData[country]) {
        pivotedData[country] = { country };
      }
      let combined_name = row.group + "-" + row.variable;
      pivotedData[country][combined_name] = row.value;
    });

    return Object.values(pivotedData);
  }

  function calculateMeans(data) {
    const groupedData = {};

    // Group data by variable
    data.forEach((row) => {
      let combined_name = row.group + "-" + row.variable;
      if (!groupedData[combined_name]) {
        groupedData[combined_name] = [];
      }
      groupedData[combined_name].push(row.value);
    });

    // Calculate mean for each variable
    const means = {};
    for (const [variable, values] of Object.entries(groupedData)) {
      const sum = values.reduce((acc, val) => acc + val, 0);
      means[variable] = sum / values.length;
    }

    return [means];
  }
};
```

```{ojs}
parallelCoordinatesScatterPlot2 = async () => {
  const margin = { top: 60, right: 80, bottom: 25, left: 40 },
    width = 1200 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;

  let group_query = `AND "group" in (${
    "'" +
    DataSelector_form.vulnerabilityGroup_form.vulnerability_sel
      .join("', '")
      .toLowerCase() +
    "'"
  })`;

  let data = await db.query(
    `SELECT "admin0_name", "admin1_name", "admin2_name", "group", "variable", "value"
     FROM Vulnerability 
     ${plotQuery2_admin}
     AND "variable" != 'GenderEquity_1995.2015'
     ${group_query}`,
  );

  const data_vuln = pivotData(data);
  let means = calculateMeans(data);
  means.country = "Regional Average";

  const dimensions = Object.keys(data_vuln[0]).filter((d) => d !== "country");
  const jitter = d3.randomUniform(-20, 20);

  const color = d3
    .scaleOrdinal()
    .domain(data_vuln.map((d) => d.country))
    .range(d3.schemeCategory10);

  const svg = d3
    .create("svg")
    .attr("id", "VulnerableParallelScatter")
    .attr("viewBox", [0, 0, width, height])
    .attr("width", width)
    .attr("height", height);

  // Define the variable categories (gender, poverty, education)
  const categories = {
    gender: {
      values: dimensions.filter((d) => d.startsWith("gender")),
      range: [0, 1],
      unit: 10,
    },
    poverty: {
      values: dimensions.filter((d) => d.startsWith("poverty")),
      range: [0, 1],
      unit: "percent_NoDecimal",
    },
    education: {
      values: dimensions.filter((d) => d.startsWith("education")),
      range: [0, 13],
      unit: "total",
    },
  };

  // Flatten the categories into a single array, adding gaps between groups
  const groupedDimensions = [
    ...categories.gender.values,
    ...categories.poverty.values,
    ...categories.education.values,
  ];

  // Define the x scale, with larger spacing for the gaps
  const x = d3
    .scalePoint()
    .domain(groupedDimensions)
    .range([margin.left, width - margin.right])
    .padding(0.3); // Add extra padding for the gaps

  const y = {};
  for (const dim of groupedDimensions) {
    let group = dim.split("-")[0];
    let y_extent = categories[group].range;
    y[dim] = d3
      .scaleLinear()
      .domain(y_extent)
      .range([height - margin.bottom, margin.top]);
  }

  d3.selectAll(".ParallelCoordTip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip ParallelCoordTip")
    .style("position", "absolute");

  // Create circles for each data point
  groupedDimensions.forEach((dim) => {
    if (dim === "") return; // Skip gaps

    svg
      .selectAll(`.dot-${dim}`)
      .data(data_vuln)
      .join("circle")
      .attr(
        "class",
        (d) => `dot-${dim} country-${d.country.replace(/\s+/g, "-")}`,
      )
      .attr("cx", () => x(dim) + jitter())
      .attr("cy", (d) => {
        return y[dim](d[dim]);
      })
      .attr("r", 5)
      .style("fill", "lightgrey")
      .style("opacity", 0.5)
      .on("mouseover", function (event, d) {
        svg
          .selectAll(`.country-${d.country.replace(/\s+/g, "-")}`)
          .attr("r", 8)
          .style("opacity", 1)
          .style("fill", (d) => color(d.country))
          .raise();
        tooltip
          .style("top", event.pageY - 1 + "px")
          .style("left", event.pageX + 1 + "px")
          .style("opacity", 0.8)
          .style("display", "block")
          .html(() => {
            let admin_string = d.country;
            let admin_names = admin_string.split("_");
            let admin0_name = admin_names[0];
            let admin_join = admin_names
              .filter((name) => name !== "null")
              .join(", ");
            let splitVar = dim.split("-");
            let varname = _lang(nbText.general.acVars[splitVar[1]]);
            let varValue = format_val(d[dim], categories[splitVar[0]].unit);
            return `${admin_join}<br/>${varname}: ${varValue}`;
          });
        // .html(`${d.country}<br/>${dim}: ${d[dim].toFixed(2)}`);
      })
      .on("mouseout", function (event, d) {
        svg
          .selectAll(`.country-${d.country.replace(/\s+/g, "-")}`)
          .attr("r", 5)
          .style("opacity", 0.5)
          .style("fill", "lightgrey")
          .lower();
        tooltip.style("display", "none");
      });
  });

  // Add average points
  let avg_points = svg
    .selectAll(".avg-dot")
    .data(groupedDimensions)
    .enter()
    .append("circle")
    .attr("class", "avg-dot")
    .attr("cx", (d) => x(d))
    .attr("cy", (d) => y[d](means[0][d]))
    .attr("r", 7)
    .style("fill", "#2E7636")
    .style("stroke", "white")
    .style("stroke-width", 2);

  avg_points
    .on("mouseover", function (event, d) {
      svg.selectAll(`.avg-dot`).raise();
      tooltip
        .style("top", event.pageY - 1 + "px")
        .style("left", event.pageX + 1 + "px")
        .style("opacity", 0.8)
        .style("display", "block")
        .html(() => {
          let admin_name = means.country;
          let splitVar = d.split("-");
          let varname = _lang(nbText.general.acVars[splitVar[1]]);
          let varValue = format_val(means[0][d], categories[splitVar[0]].unit);
          return `${admin_name}<br/>${varname}: ${varValue}`;
        });
      // .html(`${d.country}<br/>${dim}: ${d[dim].toFixed(2)}`);
    })
    .on("mouseout", function (event, d) {
      svg.selectAll(`.avg-dot`);
      // .lower();
      tooltip.style("display", "none");
    });

  svg
    .selectAll("myAxis")
    .data(groupedDimensions)
    .enter()
    .append("g")
    .attr("transform", (d) => "translate(" + x(d) + ")")
    .attr("pointer-events", "none")
    .each(function (d) {
      let group = d.split("-")[0];
      d3.select(this).call(
        d3
          .axisLeft()
          .scale(y[d])
          .tickFormat((v) => format_val(v, categories[group].unit)),
      );
    })
    .append("text")
    .style("text-anchor", "middle")
    .attr("y", (d, i) => {
      return i % 2 === 0 ? margin.top - 10 : height - margin.bottom + 20;
    })
    .text((d) => {
      let split = d.split("-");
      let clean_text = _lang(nbText.general.acVars[split[1]]);
      return clean_text;
    })
    .style("fill", "black")
    .style("font-size", "12px");

  const legendX = 10;
  const legendY = 5;

  const legend = svg
    .append("g")
    .attr("transform", `translate(${legendX}, ${legendY})`);

  legend
    .append("circle")
    .attr("cx", 10)
    .attr("cy", 10)
    .attr("r", 7)
    .style("fill", "#2E7636");

  // Append text next to the dot
  legend
    .append("text")
    .attr("x", 20)
    .attr("y", 15)
    .style("font-size", "12px")
    .style("fill", "#000")
    .text("Regional Average");

  return svg.node();

  function pivotData(data) {
    const pivotedData = {};

    data.forEach((row) => {
      // Use a default value for any missing (NULL) admin field
      const admin0 = row.admin0_name;
      const admin1 = row.admin1_name; //|| "";
      const admin2 = row.admin2_name; //|| ""

      // Create a unique key for each combination of admin0, admin1, admin2, admin3
      const country = `${admin0}_${admin1}_${admin2}`;

      if (!pivotedData[country]) {
        pivotedData[country] = { country };
      }

      let combined_name = row.group + "-" + row.variable;
      pivotedData[country][combined_name] = row.value;
    });

    // Return the pivoted data as an array of objects
    return Object.values(pivotedData);
  }

  function calculateMeans(data) {
    const groupedData = {};

    data.forEach((row) => {
      let combined_name = row.group + "-" + row.variable;
      if (!groupedData[combined_name]) {
        groupedData[combined_name] = [];
      }
      groupedData[combined_name].push(row.value);
    });

    const means = {};
    for (const [variable, values] of Object.entries(groupedData)) {
      const sum = values.reduce((acc, val) => acc + val, 0);
      means[variable] = sum / values.length;
    }

    return [means];
  }
};
```

```{ojs}
parallelCoordinatesScatterPlot = async () => {
  const margin = { top: 60, right: 80, bottom: 55, left: 75 },
    width = 1000,
    height = 600;

  let group_query = `AND "group" in (${
    "'" +
    DataSelector_form.vulnerabilityGroup_form.vulnerability_sel
      .join("', '")
      .toLowerCase() +
    "'"
  })`;

  let data = await db.query(
    `SELECT "admin0_name", "admin1_name", "admin2_name", "group", "variable", "value"
     FROM Vulnerability 
     ${plotQuery2_admin}
     AND "variable" != 'GenderEquity_1995.2015'
     ${group_query}`,
  );

  const data_vuln = pivotData(data);

  data_vuln.forEach((entry) => {
    Object.keys(entry).forEach((key) => {
      if (key.startsWith("poverty-")) {
        entry[key] = 1 - entry[key]; // Invert value
      }
    });
  });

  let means = calculateMeans(data_vuln);

  means.country = "Regional Average";

  const dimensions = Object.keys(data_vuln[0]).filter((d) => d !== "country");
  const jitter = d3.randomUniform(-15, 15);

  const color_dep = d3
    .scaleOrdinal()
    .domain(data_vuln.map((d) => d.country))
    .range(d3.schemeCategory10);

  const svg = d3
    .create("svg")
    .attr("id", "VulnerableParallelScatter")
    .attr("viewBox", [0, 0, width, height])
    .attr("width", width)
    .attr("height", height);

  // Define the variable categories (gender, poverty, education)
  const categories = {
    gender: {
      values: dimensions.filter((d) => d.startsWith("gender")),
      range: [0, 1],
      unit: 100,
      color: "black",
    },
    poverty: {
      values: dimensions.filter((d) => d.startsWith("poverty")),
      range: [0, 1],
      unit: "percent_NoDecimal",
      color: "black",
    },
    education: {
      values: dimensions.filter((d) => d.startsWith("education")),
      range: [0, 13],
      unit: "total",
      color: "black",
    },
  };

  const color = (group, value) => {
    // let color_range = group === 'poverty' ? ['green', 'red'] : ['red', 'green']
    let color_range = ["red", "green"];
    return d3.scaleLinear().domain(categories[group].range).range(color_range)(
      value,
    );
  };

  // Flatten the categories into a single array, adding gaps between groups
  const groupedDimensions = [
    ...categories.gender.values.sort(),
    ...categories.poverty.values.sort(),
    ...categories.education.values.sort(),
  ];

  const x = d3
    .scalePoint()
    .domain(groupedDimensions)
    .range([margin.left, width - margin.right]);

  const y_group = {
    gender: d3
      .scaleLinear()
      .domain(categories.gender.range)
      .range([height - margin.bottom, margin.top]),
    poverty: d3
      .scaleLinear()
      .domain(categories.poverty.range)
      .range([height - margin.bottom, margin.top]),
    education: d3
      .scaleLinear()
      .domain(categories.education.range)
      .range([height - margin.bottom, margin.top]),
  };

  const y = {};
  groupedDimensions
    .filter((d) => d !== "")
    .forEach((dim) => {
      let group = dim.split("-")[0];
      console.log(group);
      let y_extent = categories[group].range;
      y[dim] = d3
        .scaleLinear()
        .domain(y_extent)
        .range([height - margin.bottom, margin.top]);
    });

  d3.selectAll(".ParallelCoordTip").remove();
  const tooltip = d3
    .select("body")
    .append("div")
    .attr("class", "plotTooltip ParallelCoordTip")
    .style("position", "absolute");

  // Create circles for each data point
  groupedDimensions
    .filter((d) => d !== "")
    .forEach((dim) => {
      let splitVar = dim.split("-");
      let varname = _lang(
        nbText.ViewExplore.parallelCoords.acVars[splitVar[1]],
      );
      let group = splitVar[0];
      svg
        .selectAll(`.dot-${dim}`)
        .data(data_vuln)
        .join("circle")
        .attr(
          "class",
          (d) => `dot-${dim} country-${d.country.replace(/\s+/g, "-")}`,
        )
        .attr("cx", () => x(dim) + jitter())
        .attr("cy", (d) => {
          return y[dim](d[dim]);
        })
        .attr("r", 5)
        // .style("fill", 'lightgrey')
        .style("fill", (d) => color(group, d[dim]))
        .style("opacity", 0.1)
        .on("mouseover", function (event, d) {
          svg
            .selectAll(`.country-${d.country.replace(/\s+/g, "-")}`)
            .attr("r", 8)
            .style("opacity", 1)
            .raise();
          console.log("ttip", `.legend-${group}`);
          svg.selectAll(`.legend-${group}`).style("opacity", 1);
          tooltip
            .style("top", event.pageY - 1 + "px")
            .style("left", event.pageX + 1 + "px")
            .style("opacity", 0.8)
            .style("display", "block")
            .html(() => {
              let admin_string = d.country;
              let admin_names = admin_string.split("_");
              admin_names[0] =
                _lang(nbText.general.adminNames[admin_names[0]]) ||
                admin_names[0];
              // let admin0_name = _lang(nbText.general.adminNames[admin_names[0]])
              let admin_join = admin_names
                .filter((name) => name !== "null")
                .join(", ");
              let varValue = format_val(d[dim], categories[group].unit);
              return `${admin_join}<br/>${varname}: ${varValue}`;
            });
          // .html(`${d.country}<br/>${dim}: ${d[dim].toFixed(2)}`);
        })
        .on("mouseout", function (event, d) {
          svg
            .selectAll(`.country-${d.country.replace(/\s+/g, "-")}`)
            .attr("r", 5)
            .style("opacity", 0.1)
            .lower();

          svg.selectAll(`.legend-${group}`).style("opacity", 0.5);
          tooltip.style("display", "none");
        });
    });

  // Add average points
  let avg_points = svg
    .selectAll(".avg-dot")
    .data(groupedDimensions.filter((d) => d !== ""))
    .enter()
    .append("circle")
    .attr("class", "avg-dot")
    .attr("cx", (d) => x(d))
    .attr("cy", (d) => y[d](means[0][d]))
    .attr("r", 7)
    .style("fill", "grey")
    // .style("fill", "#2E7636")
    .style("stroke", "white")
    .style("stroke-width", 2);

  avg_points
    .on("mouseover", function (event, d) {
      let splitVar = d.split("-");
      let varname = _lang(
        nbText.ViewExplore.parallelCoords.acVars[splitVar[1]],
      );
      let group = splitVar[0];
      svg.selectAll(`.avg-dot`).attr("r", 8).raise();
      svg.selectAll(`.legend-${group}`).style("opacity", 1);
      tooltip
        .style("top", event.pageY - 1 + "px")
        .style("left", event.pageX + 1 + "px")
        .style("opacity", 0.8)
        .style("display", "block")
        .html(() => {
          let admin_name = means.country; // TODO: Lang add here
          let varValue = format_val(means[0][d], categories[group].unit);
          return `${admin_name}<br/>${varname}: ${varValue}`;
        });
      // .html(`${d.country}<br/>${dim}: ${d[dim].toFixed(2)}`);
    })
    .on("mouseout", function (event, d) {
      svg.selectAll(`.legend-${d.split("-")[0]}`).style("opacity", 1);
      svg.selectAll(`.avg-dot`).attr("r", 7);
      // .lower();
      tooltip.style("display", "none");
    });

  Object.keys(categories).forEach((cat) => {
    svg
      .append("g")
      .attr("class", `legend-${cat}`)
      .attr("transform", `translate(${x(categories[cat].values[0]) - 20},0)`)
      .style("opacity", 0.5)
      .call(
        d3
          .axisLeft(y_group[cat])
          .tickFormat((v) => format_val(v, categories[cat].unit)),
      )
      .call((g) => {
        g.selectAll(".tick text").attr("fill", categories[cat].color);
        g.selectAll(".tick line").attr("stroke", categories[cat].color);
        g.select(".domain").attr("stroke", categories[cat].color); // Axis line color
      });
    // .append("text")  // Vertical title
    // .attr("x", -40)
    // .attr("y", (height / 2))
    // .attr("text-anchor", "middle")
    // .attr("transform", `rotate(-90, -40, ${height / 2})`)
    // .style("font-size", "14px")
    // .style("fill", categories[cat].color)
    // .text(`${Lang.toSentenceCase(cat)} Variables`)
  });

  svg
    .selectAll("myAxis")
    .data(groupedDimensions)
    .enter()
    .append("g")
    .attr("transform", (d) => "translate(" + x(d) + ")")
    .attr("pointer-events", "none")
    .append("text")
    .style("text-anchor", "middle")
    .attr("y", (d, i) => {
      return i % 2 === 0 ? margin.top - 10 : height - margin.bottom + 20;
    })
    .text((d) => {
      let split = d.split("-");
      let clean_text = _lang(
        nbText.ViewExplore.parallelCoords.acVars[split[1]],
      );
      return clean_text;
    })
    .style("fill", (d) => {
      return categories[d.split("-")[0]].color;
    })
    .style("font-size", "10px");

  const dotLegendX = 10;
  const dotLegendY = 5;

  const legend = svg
    .append("g")
    .attr("transform", `translate(${dotLegendX}, ${dotLegendY})`);

  legend
    .append("circle")
    .attr("cx", 10)
    .attr("cy", 10)
    .attr("r", 8)
    .style("fill", "grey");

  // Append text next to the dot
  legend
    .append("text")
    .attr("x", 23)
    .attr("y", 15)
    .style("font-size", "13px")
    .style("fill", "#000")
    .text(_lang(nbText.general.regionalAvg));

  // Add lines and titles for each group
  addGroupTitleLine("gender", "Gender", categories.gender.color);
  addGroupTitleLine("poverty", "Poverty", categories.poverty.color);
  addGroupTitleLine("education", "Education", categories.education.color);

  //// Add a legend from red to green
  const gradientWidth = 250;
  const gradientHeight = 15;
  const legendX = width / 2 - 125;
  const legendY = 5;

  // Append a defs element for the gradient
  const defs = svg.append("defs");

  const linearGradient = defs
    .append("linearGradient")
    .attr("id", "AClinear-gradient");

  // linearGradient
  //   .append('stop')
  //     .selectAll("stop")
  //     .data([minValue, maxValue])
  //     .join("stop")
  //     .attr("offset", (d, i, n) => `${(100 * i) / (n.length - 1)}%`)
  //     .attr("stop-color", color);

  linearGradient.append("stop").attr("offset", "0%").attr("stop-color", "red");

  linearGradient
    .append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "green");

  // Draw the rectangle using the gradient
  svg
    .append("rect")
    .attr("x", legendX)
    .attr("y", legendY)
    .attr("width", gradientWidth)
    .attr("height", gradientHeight)
    .style("fill", "url(#AClinear-gradient)");

  // Add labels for the gradient
  svg
    .append("text")
    .attr("x", legendX - 5)
    .attr("y", legendY + gradientHeight / 2 + 5)
    .attr("text-anchor", "end")
    .style("font-size", "12px")
    .text("Low adaptive capacity");

  svg
    .append("text")
    .attr("x", legendX + gradientWidth + 5)
    .attr("y", legendY + gradientHeight / 2 + 5)
    .attr("text-anchor", "start")
    .style("font-size", "13px")
    .text("High adaptive capacity");

  return svg.node();

  ///// Helper Functions //////

  function pivotData(data) {
    const pivotedData = {};

    data.forEach((row) => {
      // Use a default value for any missing (NULL) admin field
      const admin0 = row.admin0_name;
      const admin1 = row.admin1_name; //|| "";
      const admin2 = row.admin2_name; //|| ""

      // Create a unique key for each combination of admin0, admin1, admin2, admin3
      const country = `${admin0}_${admin1}_${admin2}`;

      if (!pivotedData[country]) {
        pivotedData[country] = { country };
      }

      let combined_name = row.group + "-" + row.variable;
      pivotedData[country][combined_name] = row.value;
    });

    // Return the pivoted data as an array of objects
    return Object.values(pivotedData);
  }

  function calculateMeans(data) {
    const groupedData = {};
    data.forEach((row) => {
      // Loop through each key in the object (ignoring the 'country' key)
      Object.keys(row).forEach((key) => {
        if (key !== "country") {
          if (!groupedData[key]) {
            groupedData[key] = [];
          }
          groupedData[key].push(row[key]);
        }
      });
    });

    const means = {};
    for (const [variable, values] of Object.entries(groupedData)) {
      const sum = values.reduce((acc, val) => acc + val, 0);
      means[variable] = sum / values.length;
    }

    return [means];
  }

  function addGroupTitleLine(group, groupLabel, color) {
    const groupValues = categories[group].values;
    let groupStart = x(groupValues[0]) - 15;
    let groupEnd = x(groupValues[groupValues.length - 1]) + 15;

    if (groupStart === groupEnd) {
      groupStart = groupStart - 25;
      groupEnd = groupStart + 25;
    }
    svg
      .append("line")
      .attr("x1", groupStart)
      .attr("x2", groupEnd)
      .attr("y1", height - 20)
      .attr("y2", height - 20)
      .attr("stroke", color)
      .attr("stroke-width", 2);

    // Append the group label centered on the line
    svg
      .append("text")
      .attr("x", (groupStart + groupEnd) / 2) // Center the title between start and end
      .attr("y", height - 5) // Position the title above the line
      .attr("text-anchor", "middle")
      .style("font-size", "14px")
      .style("font-weight", "bold")
      .style("fill", color)
      .text(groupLabel);
  }
};
```

```{ojs}
TooltipCSS = html`<style>
.plotTooltip {
  padding: 10px 10px;
  color: black;
  border-radius: 4px;
  border: 1px solid rgba(0,0,0,1);
  pointer-events: none;
  transform: translate(-50%, -100%);
  font-family: "IBM Plex Sans", "Source Serif Pro";
  font-size: 14px;
  background: rgba(255,255,255, 1);
  transition: 0.3s opacity ease-out, 0.1s border-color ease-out;
  position: relative;
  display: none;
}

.plotTooltip::before {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: black transparent transparent transparent;
}

.plotTooltip::after {
  content: "";
  position: absolute;
  top: calc(100% - 1px);
  left: 50%;
  margin-left: -4.9px;
  border-width: 4.9px;
  border-style: solid;
  border-color: white transparent transparent transparent;
}
</style>`;
```

```{ojs}
function tocOneliner({
  selector = "h1", // selectors to include (can comma-separate, like "h1,h2,h3")
  heading = "<b>In this notebook</b>", // heading for ToC
  delim = "&nbsp;|&nbsp;", // delimiter between links
  skip = [], // text content for headers to exclude
} = {}) {
  // return a one-liner table of contents
  // allow for skips
  // modified from https://observablehq.com/@mbostock/toc

  return Generators.observe((notify) => {
    let headings = [];

    function observed() {
      let h = Array.from(document.querySelectorAll(selector));
      h = h.filter((d) => !skip.includes(d.textContent));
      if (h.length !== headings.length || h.some((h, i) => headings[i] !== h)) {
        notify(
          html`${heading}<br>${Array.from((headings = h), (h, i) => {
            const end = i === headings.length - 1;
            return Object.assign(
              html`<a href=#${h.id}>${DOM.text(h.textContent)}</a>${
                end ? "" : delim
              }`,
              { onclick: (e) => (e.preventDefault(), h.scrollIntoView()) },
            );
          })}`,
        );
      }
    }

    const observer = new MutationObserver(observed);
    observer.observe(document.body, { childList: true, subtree: true });
    observed();
    return () => observer.disconnect();
  });
}
```

```{ojs}
md`## Language and Translation tools`;
```

```{ojs}
import { Lang } from "7d46679f7d0d917e";
```

```{ojs}
_lang = Lang.lg(language.key);
```

```{ojs}
languages = [
  { key: "en", label: "English", locale: "en-US" },
  { key: "fr", label: "Français", locale: "fr-FR" },
];
```

```{ojs}
defaultLangKey = {
  const name = "lang";
  const list = languages.map((d) => d.key);
  const defaultKey = "en";

  const queryParam = await Lang.getParamFromList({ name, list });

  return queryParam ?? defaultKey;
}
```

```{ojs}
viewof language = Inputs.radio(languages, {
  label: "Main language toggle",
  format: (d) => d.key,
  value: languages.find((x) => x.key === defaultLangKey),
})
```

```{ojs}
nbText = new Object({
  nbTitle: { en: "Explore The Datasets", fr: "Explorez les données" },
  toc: {
    title: { en: "In this notebook", fr: "Dans ce notebook" },
  },
  overview: {
    title: { en: "Overview", fr: "Vue d’Ensemble" },
    subTitle: {
      en: `Explore and export the data in the [Adaptation Atlas](https://adaptationatlas.cgiar.org)`,
      fr: `Explorez et exportez les données de [L’Adaptation l'Atlas](https://adaptationatlas.cgiar.org)`,
    },
    text: {
      en: "This notebook enables you to explore and download the data that underpins much of the analysis within the African Agricultural Adaptation Atlas. Filter and export the data in multiple formats to perform external analysis or use the tables and plots in this notebook to gain insights into broad continental trends or region-specific statistics.",
      fr: "Ce notebook vous permet d'explorer et de télécharger les données qui constituent la base d’une grande partie de l'analyse au sein de African Agricultural Adaptation Atlas. Filtrez et exportez les données dans plusieurs formats pour effectuer des analyses externes ou utilisez les tableaux et graphiques de ce notebook pour obtenir des aperçus sur les tendances continentales générales ou les statistiques spécifiques à une région.",
    },
  },
  selectCategory: {
    title_main: {
      en: "Define The Data Focus",
      fr: "Définir le focus des données",
    },
    title: { en: "Select A Category", fr: "Sélectionnez une catégorie" },
    text: {
      en: "Choose between these categories: Hazard, Adaptive Capacity, and Exposure. These three categories are essential for a comprehensive understanding of climate risk, enabling effective assessment and management strategies.",
      fr: "Choisissez parmi ces catégories : Aléa, Capacité d'adaptation et Exposition. Ces trois catégories sont essentielles pour une compréhension globale du risque climatique, permettant des stratégies d'évaluation et de gestion efficaces.",
    },
    selector: {
      title: { en: "Category", fr: "Catégorie " },
      options: {
        Hazard: {
          title: { en: "Hazard", fr: "Aléa" },
          description: {
            en: "Climate Hazards include individual, extreme climate events as well as shifting trends over time. Both acute events and long term changes can pose a serious threat to crops, livestock, people, and other assets.",
            fr: "Les aléas climatiques incluent des événements climatiques extrêmes individuels ainsi que des tendances changeantes au fil du temps. Tant les événements aigus que les changements à long terme peuvent représenter une menace sérieuse pour les cultures, le bétail, les personnes et d'autres actifs.",
          },
        },
        Vulnerability: {
          title: { en: "Adaptive Capacity", fr: "Capacité d'adaptation" },
          description: {
            en: "A population's ability to adapt to a changing climate is directly influenced by different socio-economic variables. Variables such as education, female empowerment, and poverty can promote or inhibit a person's ability to respond, recover, and adapt to climate related risks.",
            fr: "La capacité d'une population à s'adapter à un climat changeant est directement influencée par différentes variables socio-économiques. Des variables telles que l'éducation, l'autonomisation des femmes et la pauvreté peuvent favoriser ou entraver la capacité d'une personne à répondre, se rétablir et s'adapter aux risques liés au climat.",
          },
        },
        Exposure: {
          title: { en: "Exposure", fr: "Exposition" },
          description: {
            en: "Crop and livestock production systems are vulnerable to climate hazards such as heat stress, temperature fluctuations, and changes in precipitation patterns. Agriculture in Sub-Saharan Africa is primarily driven by small-holder farmers and plays an important role in both global and local food security. Exposure happens when these livelihoods and commodities are exposed to hazardous climate conditions. To fully understand climate risk, the level and scale of exposure must be understood.",
            fr: "Les systèmes de production des cultures et du bétail sont vulnérables aux aléas climatiques tels que le stress thermique, les fluctuations de température et les changements dans les régimes de précipitations. L'agriculture en Afrique subsaharienne est principalement portée par de petits exploitants agricoles et joue un rôle important dans la sécurité alimentaire tant mondiale que locale. L'exposition se produit lorsque ces moyens de subsistance et ces produits sont confrontés à des conditions climatiques dangereuses. Pour comprendre pleinement le risque climatique, le niveau et l'échelle de l'exposition doivent être évalués.",
          },
        },
      },
    },
  },
  selectVars: {
    title: {
      en: "Select the variables of interest",
      fr: "Sélectionnez les variables d'intérêt",
    },
    text: {
      en: "There are many different variables within the categories of hazard, exposure, and vulnerability. Use the selector below to choose one or multiple of these variables to explore or download.",
      fr: "Il existe de nombreuses variables différentes dans les catégories d'aléa, d'exposition et de vulnérabilité. Utilisez le sélecteur ci-dessous pour choisir une ou plusieurs de ces variables à explorer ou à télécharger.",
    },
    forms: {
      Hazard: {
        mainTitle: {
          en: "Hazard Selectors (One of each must be selected)",
          fr: "Sélecteurs d'Aléas (Un de chaque doit être sélectionné)",
        },
        selectors: {
          hazard: {
            title: { en: "Hazard", fr: "Aléa" },
          },
          period: {
            title: { en: "Time Period", fr: "Période de temps" },
            options: {
              baseline: { en: "Baseline", fr: "Référence" },
              historic: { en: "Baseline", fr: "Référence" },
              "2021_2040": { en: "2040", fr: "2040" },
              "2041_2060": { en: "2060", fr: "2060" },
            },
          },
        },
      },
      Vulnerability: {
        mainTitle: {
          en: "Adaptive Capacity Selectors",
          fr: "Sélecteurs de capacité d’adaptation",
        },
        selectors: {
          variable: {
            title: { en: "Variables", fr: "Variables" },
            options: {
              Gender: { en: "Gender", fr: "Genre" },
              Education: { en: "Education", fr: "Éducation" },
              Poverty: { en: "Poverty", fr: "Pauvreté" },
            },
          },
        },
      },
      Exposure: {
        mainTitle: {
          en: "Exposure Selectors",
          fr: "",
        },
        selectors: {
          variable: {
            title: { en: "Variables", fr: "Variables" },
            options: {
              Crop: { en: "Crop", fr: "Cultures" },
              Livestock: { en: "Livestock", fr: "Bétail" },
              Population: { en: "Population", fr: "Population" },
            },
          },
        },
      },
    },
  },
  selectGeog: {
    title: {
      en: "Select Geographies",
      fr: "Sélectionnez les géographies",
    },
    text: {
      en: "Use the toggles below to explore data and spatial patterns within your region of interest. Adjust the aggregation level to reveal patterns of hazard, vulnerability, and exposure, both within and between countries. These crucial insights often become clear only when viewed at higher spatial resolutions. Once you've selected an aggregation level, you can use the country, region, and sub-region selectors to focus on specific areas.",
      fr: "Utilisez les options ci-dessous pour explorer les données et les modèles spatiaux dans votre région d'intérêt. Ajustez le niveau d'agrégation pour révéler les schémas d'aléa, de vulnérabilité et d'exposition, à la fois au sein des pays et entre eux. Ces informations cruciales deviennent souvent claires uniquement lorsqu'elles sont observées à des résolutions spatiales plus élevées. Une fois que vous avez sélectionné un niveau d'agrégation, vous pouvez utiliser les sélecteurs de pays, de région et de sous-région pour vous concentrer sur des zones spécifiques.",
    },
    selectors: {
      aggregationLvl: {
        title: { en: "Map Level", fr: "Niveau cartographique" },
        options: {
          admin0_name: { en: "Country", fr: "Pays" },
          admin1_name: { en: "Region", fr: "Région" },
          admin2_name: { en: "Sub-Region", fr: "Sous-région" },
        },
        warning: {
          en: "Warning: Selecting all sub-regions in SSA may affect page performance",
          fr: "",
        },
      },
      admin0_name: {
        title: { en: "Country", fr: "Pays" },
      },
      admin1_name: {
        title: { en: "Region", fr: "Région" },
      },
      admin2_name: {
        title: { en: "Sub-Region", fr: "Sous-région" },
      },
    },
  },
  ViewExplore: {
    title: { en: "Interact with the data", fr: "Interagir avec les données" },
    text: {
      en: "Use the map below to view spatial patterns in the data, select the table to preview the data before downloading it, or gain quick insights using the plots.",
      fr: "Utilisez la carte ci-dessous pour visualiser les modèles spatiaux dans les données, sélectionnez le tableau pour prévisualiser les données avant de les télécharger, ou obtenez rapidement des informations en utilisant les graphiques.",
    },
    selectors: {
      preview: {
        title: { en: "Preview Type", fr: "Type d'Aperçu" },
        options: {
          Map: { en: "Map", fr: "Carte" },
          Table: { en: "Table", fr: "Tableau" },
          Plot: { en: "Plot", fr: "Graphique" },
        },
      },
      visualiseVars: {
        titleMap: { en: "Variable To Map", fr: "Variable à cartographier" },
        titlePlot: { en: "Variable To Plot", fr: "" },
        hazards: {
          // hazard and timeperiod can be stolen from other section
          scenario: {
            title: { en: "Scenario", fr: "Scénario" },
          },
        },
        vulnerability: {
          gender: {
            title: { en: "Gender Variable", fr: "Variable de Genre" },
            options: {
              domestic_violence: {
                en: "Domestic Safety",
                fr: "Sécurité domestique",
              },
              gender_equity: { en: "Gender Equity", fr: "Égalité des sexes" },
              decision_making: {
                en: "Decision Making Power",
                fr: "Pouvoir de décision",
              },
              education: { en: "Womens Education", fr: "Éducation des femmes" },
              family_planning: {
                en: "Access to Family Planning",
                fr: "Accès à la planification familiale",
              },
              reproductive_health: {
                en: "Reproductive Health",
                fr: "Santé reproductive",
              },
            },
          },
          poverty: {
            title: { en: "Poverty variable", fr: "Variable de Pauvreté" },
            options: {
              GSAP_poor215: { en: "% under $2.15 poverty line", fr: "" },
              GSAP_poor365: { en: "% under $3.65 poverty line", fr: "" },
              GSAP_poor685: { en: "% under $6.85 poverty line", fr: "" },
            },
          },
        },
        exposure: {
          title: { en: "Exposure Category", fr: "Catégorie d'Exposition" },
          population: {
            title: { en: "Population Group", fr: "Groupe de Population" },
            options: {
              total_pop: { en: "Total Population", fr: "Population Totale" },
              rural_pop: { en: "Rural Population", fr: "Population Rurale" },
              urban_pop: { en: "Urban Population", fr: "Population Urbaine" },
            },
          },
          commodity: {
            title: { en: "Commodity", fr: "Produit" },
          },
          exposureVariable: {
            title: { en: "Variable", fr: "Variable" },
            options: {
              total_pop: { en: "Total Population", fr: "Population Totale" },
              rural_pop: { en: "Rural Population", fr: "Population Rurale" },
              urban_pop: { en: "Urban Population", fr: "Population Urbaine" },
              vop: { en: "Value of Production", fr: "Valeur de la Production" },
              ha: { en: "Harvested Area", fr: "Superficie Récoltée" },
              number: { en: "Number of Animals", fr: "Nombre d'Animaux" },
            },
          },
        },
      },
    },
    exploreMap: {
      resetBtn: { en: "Reset Zoom", fr: "Réinitialiser le zoom" },
      value: { en: "Value", fr: "Valeur" },
    },
    hazardBars: {
      numAreas: {
        en: "Number of Areas",
        fr: "Nombre d'Unités Administratives",
      },
      yaxis: {
        en: "Number of Admin Units",
        fr: "Nombre d'Unités Administratives",
      },
      lvl: { en: "Level", fr: "" },
    },
    exposureTreemap: {
      cropGroups: {
        total: { en: "Total", fr: "Total" },
        cattle: { en: "Cattle", fr: "Bovins" },
        poultry: { en: "Poultry", fr: "Volailles" },
        pigs: { en: "Pigs", fr: "Porcs" },
        cereals: { en: "Cereals", fr: "Céréales" },
        rootsTuber: { en: "Roots & Tubers", fr: "Racines et Tubercules" },
        legumes: { en: "Legumes", fr: "Légumineuses" },
        fruitVeg: { en: "Fruits & Vegetables", fr: "Fruits et Légumes" },
        nonEdible: { en: "Non-edible Crops", fr: "Cultures non comestibles" },
      },
    },
    parallelCoords: {
      acVars: {
        domestic_violence: {
          en: "Domestic Safety",
          fr: "Sécurité domestique",
        },
        gender_equity: {
          en: "Gender Equity",
          fr: "Égalité des sexes",
        },
        decision_making: {
          en: "Decision Making Power",
          fr: "Pouvoir de décision",
        },
        education: {
          en: "Womens Education",
          fr: "Éducation des femmes",
        },
        family_planning: {
          en: "Access to Family Planning",
          fr: "Accès à la planification familiale",
        },
        reproductive_health: {
          en: "Reproductive Health",
          fr: "Santé reproductive",
        },
        GSAP_poor215: {
          en: "Above $2.15/day",
          fr: "Au-dessus de 2,15 $/jour",
        },
        GSAP_poor365: {
          en: "Above $3.65/day",
          fr: "Au-dessus de 3,65 $/jour",
        },
        GSAP_poor685: {
          en: "Above $6.85/day",
          fr: "Au-dessus de 6,85 $/jour",
        },
        educationYrs: {
          en: "Education(Yrs)",
          fr: "Éducation (années)",
        },
      },
    },
  },
  download: {
    title: { en: "Download The Data", fr: "Télécharger les données" },
    selector: {
      title: { en: "Download Format", fr: "Format de téléchargement" },
    },
    button: {
      prepare: { en: "Prepare Download", fr: "Préparer le téléchargement" },
      download: { en: "Download", fr: "Télécharger" },
    },
    boundaries: {
      title: {
        en: "Download Boundary Data",
        fr: "Télécharger les données des frontières",
      },
      button: {
        en: "Download Admin :::adminLvl::: Boundaries",
        fr: "Télécharger les frontières administratives :::adminLvl:::",
      },
    },
  },
  methods_sources: {
    title: { en: "Methods & Sources", fr: "Méthodes & Sources" },
    methods: {
      title: { en: "Methods", fr: "Méthodologie" },
    },
    datasets: {
      title: { en: "Datasets", fr: "Jeux de données" },
      boundaries: {
        title: { en: "Boundaries", fr: "Délimitations" },
        text: {
          en: `[Administrative areas](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/boundary_catalog/geoBoundaries_SSA/collection.json) used in this notebook come from [geoBoundaries 6.0.0](https://github.com/wmgeolab/geoBoundaries). The gbHumanitarian boundaries are used and if not available then the gbOpen boundaries are substituted.`,
          fr: `[Les zones administratives](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/boundary_catalog/geoBoundaries_SSA/collection.json?.language=fr) utilisées dans ce notebook proviennent de [geoBoundaries 6.0.0](https://github.com/wmgeolab/geoBoundaries). Les frontières gbHumanitarian sont utilisées et, si elles ne sont pas disponibles, les frontières gbOpen sont substituées.`,
        },
      },
      acDS: {
        title: {
          en: "Adaptive Capacity Datasets",
          fr: "Jeux de données sur la capacité d’adaptation",
        },
        FemaleWellbeing: {
          title: {
            en: "Female Well-being and Empowerment data",
            fr: "Données sur le bien-être et l'autonomisation des femmes",
          },
          text: {
            en: `The [Female Empowerment Index](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/adaptive-capacity/women-and-gender/female-empowerment/collection.json) combines data on domestic violence, employment, reproductive healthcare, decision-making power, and family planning. The index, and the variables it is derived from, are from [Rettig, Erica (2022)](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/8GJKYW) and are build using data from [DHS Program](https://dhsprogram.com). The individual variables and the Empowerment Index are based on the 2015 calculations. All of these have been normalized between 0 and 1, where 0 represents lowest empowerment and 1 represents highest empowerment`,
            fr: `[L'Indice d'Autonomisation des Femmes](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/adaptive-capacity/women-and-gender/female-empowerment/collection.json?.language=fr) combine des données sur la violence domestique, l'emploi, les soins de santé reproductive, le pouvoir de décision et la planification familiale. L'indice, et les variables dont il est dérivé, proviennent de [Rettig, Erica (2022)](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/8GJKYW) et sont construits à partir des données du [programme DHS](https://dhsprogram.com). Les variables individuelles et l'Indice d'Autonomisation sont basés sur les calculs de 2015. Tous ces éléments ont été normalisés entre 0 et 1, où 0 représente le plus faible niveau d'autonomisation et 1 le plus élevé.`,
          },
        },
        poverty: {
          title: {
            en: "Poverty",
            fr: "Pauvreté",
          },
          text: {
            en: md`Poverty data is derived from the [World Bank global subnational poverty atlas](https://datacatalog.worldbank.org/search/dataset/0042041/global_subnational_poverty_atlas_gsap) dataset.`,
            fr: md`Les données sur la pauvreté sont tirées de [l'ensemble de données de l'atlas mondial de la pauvreté infranationale de la Banque mondiale](https://datacatalog.worldbank.org/search/dataset/0042041/global_subnational_poverty_atlas_gsap).`,
          },
        },
        education: {
          title: { en: "Education", fr: "Éducation" },
          text: {
            en: "Years of education is the mean male and female educational attainment from the [2005-2015 IHME Estimates for ages 15-49](https://ghdx.healthdata.org/record/ihme-data/africa-educational-attainment-geospatial-estimates-2000-2015).",
            fr: "Les années d’éducation correspondent à la moyenne de la scolarité des hommes et des femmes, selon les estimations de l’IHME pour la période [2005-2015 pour les personnes âgées de 15 à 49 ans.](https://ghdx.healthdata.org/record/ihme-data/africa-educational-attainment-geospatial-estimates-2000-2015)",
          },
        },
      },
      exposureDS: {
        title: {
          en: "Exposure Datasets",
          fr: "Jeux de données sur l’exposition",
        },
        population: {
          title: {
            en: "Population",
            fr: "Population",
          },
          text: {
            en: "Population data is from the WorldPop Unconstrained Global Mosaic for 2020. The population data is masked Africapolis data to separate the population groups into rural, urban, and total. The final raster dataset used is at a resolution of 0.083 degrees (5 arc minutes).",
            fr: "Les données démographiques proviennent de la mosaïque mondiale sans contrainte WorldPop pour 2020. Les données démographiques sont des données Africapolis masquées pour séparer les groupes de population en zones rurales, urbaines et totales. Le jeu de données raster final utilisé a une résolution de 0,083 degré (5 minutes d'arc).",
          },
        },
        vopHA: {
          title: {
            en: "Crop and Livestock data",
            fr: "Données sur les cultures et le bétail",
          },
          text: {
            en: md`[Crop value of production](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/exposure_catalog/mapspam2017/mapspam2017_vop_parquet/mapspam2017_vop_parquet.json) data comes from MapSPAM 2017 V2r3 (Spatial Production Allocation Model) where production values are multiplied by country specific FAOstat international crop prices in (2005 International Dollars). An [international dollar](https://en.wikipedia.org/wiki/International_dollar) (2005) is a hypothetical unit of currency that has the same purchasing power parity as the U.S. dollar had in the United States in 2005, allowing for comparison of what consumers can buy in different countries with the same amount of money. This dataset is an updated version of MapSPAM specifically tailored for this project. It includes bug fixes and incorporates country-specific values of production instead of global averages.

[Livestock value of production](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/exposure_catalog/GLW3_livestock/GLW3_livestock_vopPQ/GLW3_livestock_vopPQ.json) in 2005 International Dollars were provided by the authors of [Herrero et al. (2013)](https://www.pnas.org/doi/full/10.1073/pnas.1308149110/).`,
            fr: md`[Les données sur la valeur de la production des cultures](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/exposure_catalog/mapspam2017/mapspam2017_vop_parquet/mapspam2017_vop_parquet.json) proviennent de MapSPAM 2017 V2r3 (Modèle d'Allocation de Production Spatiale) où les valeurs de production sont multipliées par les prix internationaux des cultures de la FAOstat spécifiques à chaque pays en (dollars internationaux de 2005). Un [dollar international](https://en.wikipedia.org/wiki/International_dollar) (2005) est une unité monétaire hypothétique qui a la même parité de pouvoir d'achat que le dollar américain aux États-Unis en 2005, ce qui permet de comparer ce que les consommateurs peuvent acheter dans différents pays avec la même somme d'argent. Cet ensemble de données est une version mise à jour de MapSPAM spécialement conçue pour ce projet. Il comprend des corrections de bogues et incorpore des valeurs de production spécifiques à chaque pays au lieu de moyennes mondiales.

[La valeur de la production animale](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/exposure_catalog/GLW3_livestock/GLW3_livestock_vopPQ/GLW3_livestock_vopPQ.json) en dollars internationaux de 2005 a été fournie par les auteurs de [Herrero et al. (2013)](https://www.pnas.org/doi/full/10.1073/pnas.1308149110/).
`,
          },
        },
      },
      Hazards: {
        title: {
          en: "Historic and future climate hazards",
          fr: "Risques climatiques historiques et futurs",
        },
        text: {
          en: md`[Climate hazards](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/hazard_catalog/catalog.json) were calculated using five datasets [CHIRPS](https://www.chc.ucsb.edu/data/chirps)/[CHIRTS](https://www.chc.ucsb.edu/data/chirtsdaily), [AgERA5](https://doi.org/10.24381/cds.6c68c9bb), [CMIP6 projections](https://github.com/SantanderMetGroup/ATLAS), and [crop calendars](https://zenodo.org/records/5062513). Using the R workflows mentioned below the hazard values were summarized for each 3 month window as well as the annual average and extracted by administrative boundaries to generate a tabular parquet dataset.`,
          fr: md`[Les risques climatiques](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/hazard_catalog/catalog.json) ont été calculés à l'aide de cinq ensembles de données : [CHIRPS](https://www.chc.ucsb.edu/data/chirps)/[CHIRTS](https://www.chc.ucsb.edu/data/chirtsdaily), [AgERA5](https://doi.org/10.24381/cds.6c68c9bb), [projections CMIP6](https://github.com/SantanderMetGroup/ATLAS) et [calendriers de cultures](https://zenodo.org/records/5062513). À l'aide des flux de travail R mentionnés ci-dessous, les valeurs de risque ont été résumées pour chaque fenêtre de 3 mois ainsi que la moyenne annuelle et extraites par limites administratives pour générer un ensemble de données de parquet tabulaire.`,
        },
      },
    },
  },
  STAC: {
    title: {
      en: "Learn about the data in the Atlas STAC",
      fr: "En savoir plus sur les données dans l'Atlas STAC",
    },
    text: {
      en: `Browse and access data through the [STAC (Spatio Temporal Asset Catalog)](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/catalog.json) for all datasets related to the Africa Agriculture Adaptation Atlas. The data provided in this notebook is limited to our processed and admin level datasets. However, raster data for all of our analysis can be found and downloaded using our STAC and S3 bucket. The below example will walk you through how to explore and access the data using the STAC in R or Python, or explore the data using the no-code interface.`,
      fr: `Parcourez et accédez aux données via le [STAC (Catalogue d'Actifs Spatio-Temporels)](https://radiantearth.github.io/stac-browser/#/external/digital-atlas.s3.amazonaws.com/stac/public_stac/catalog.json) pour tous les ensembles de données liés à l'Atlas Africain d'Adaptation Agricole. Les données fournies dans ce notebook se limitent à nos ensembles de données traités et au niveau administratif. Cependant, les données raster pour toutes nos analyses peuvent être trouvées et téléchargées en utilisant notre STAC et notre bucket S3. L'exemple ci-dessous vous guidera sur la manière d'explorer et d'accéder aux données en utilisant le STAC en R ou Python, ou d'explorer les données en utilisant l'interface sans code.`,
    },
  },
  general: {
    hazards: {
      HSH_mean: {
        en: "Mean Human Heat Stress",
        fr: "Stress thermique humain moyen",
      },
      HSH_max: {
        en: "Max Human Heat Stress",
        fr: "Stress thermique humain maximal",
      },
      NDWL0: {
        en: "Number of Waterlogging Days",
        fr: "Nombre de jours de saturation en eau",
      },
      NDWS: {
        en: "Number of Days of Water Stress",
        fr: "Nombre de jours de stress hydrique",
      },
      NTx35: {
        en: "Number of Heat Stress Days for Maize",
        fr: "Nombre de jours de stress thermique pour le maïs",
      },
      NTx40: {
        en: "Number of Heat Stress Days for Generic Crops",
        fr: "Nombre de jours de stress thermique pour les cultures génériques",
      },
      TAI: {
        en: "Thornthwaite's Aridity Index",
        fr: "Indice d'Aridité de Thornthwaite",
      },
      THI_max: {
        en: "Max Cattle Thermal Humidity Index",
        fr: "Indice de Température-Humidité Maximal pour le Bétail",
      },
      THI_mean: {
        en: "Mean Cattle Thermal Humidity Index",
        fr: "Indice de Température-Humidité Moyen pour le Bétail ",
      },
      TAVG: { en: "Average Temperature", fr: "Température Moyenne" },
      PTOT: { en: "Total Precipitation", fr: "Précipitation Totale" },
    },
    commodities: {
      wheat: { en: "Wheat", fr: "Blé" },
      rice: { en: "Rice", fr: "Riz" },
      maize: { en: "Maize", fr: "Maïs" },
      barley: { en: "Barley", fr: "Orge" },
      "pearl millet": { en: "Pearl Millet", fr: "Millet Perlé" },
      "small millet": { en: "Small Millet", fr: "Petit Millet" },
      sorghum: { en: "Sorghum", fr: "Sorgho" },
      potato: { en: "Potato", fr: "Pomme de Terre" },
      "sweet potato": { en: "Sweet Potato", fr: "Patate Douce" },
      yams: { en: "Yams", fr: "Igname" },
      cassava: { en: "Cassava", fr: "Manioc" },
      bean: { en: "Bean", fr: "Haricot" },
      chickpea: { en: "Chickpea", fr: "Pois Chiche" },
      cowpea: { en: "Cowpea", fr: "Niébé" },
      pigeonpea: { en: "Pigeonpea", fr: "Pois Cajan" },
      lentil: { en: "Lentil", fr: "Lentille" },
      soybean: { en: "Soybean", fr: "Soja" },
      groundnut: { en: "Groundnut", fr: "Arachide" },
      coconut: { en: "Coconut", fr: "Noix de Coco" },
      oilpalm: { en: "Oil Palm", fr: "Palmier à Huile" },
      sunflower: { en: "Sunflower", fr: "Tournesol" },
      rapeseed: { en: "Rapeseed", fr: "Colza" },
      sesameseed: { en: "Sesame Seed", fr: "Graines de Sésame" },
      sugarcane: { en: "Sugarcane", fr: "Canne à Sucre" },
      sugarbeet: { en: "Sugarbeet", fr: "Betterave à Sucre" },
      cotton: { en: "Cotton", fr: "Coton" },
      "arabica coffee": { en: "Arabica Coffee", fr: "Café Arabica" },
      "robusta coffee": { en: "Robusta Coffee", fr: "Café Robusta" },
      cocoa: { en: "Cocoa", fr: "Cocoa" },
      tea: { en: "Tea", fr: "thé" },
      tobacco: { en: "Tobacco", fr: "Tabac" },
      banana: { en: "Banana", fr: "Banane" },
      plantain: { en: "Plantain", fr: "Banane Plantain" },
      cattle_tropical: { en: "Tropical Cattle", fr: "Bovins tropicaux" },
      poultry_tropical: { en: "Tropical Poultry", fr: "Volaille tropicale" },
      pigs_tropical: { en: "Tropical Pigs", fr: "Porcs tropicaux" },
      sheep_tropical: { en: "Tropical Sheep", fr: "Moutons tropicaux" },
      goats_tropical: { en: "Tropical Goats", fr: "Chèvres tropicales" },
      cattle_highland: {
        en: "Highland Cattle",
        fr: "Bovins des hauts plateaux",
      },
      poultry_highland: {
        en: "Highland Poultry",
        fr: "Volaille des hauts plateaux",
      },
      pigs_highland: { en: "Highland Pigs", fr: "Porcs des hauts plateaux" },
      sheep_highland: {
        en: "Highland Sheep",
        fr: "Moutons des hauts plateaux",
      },
      goats_highland: {
        en: "Highland Goats",
        fr: "Chèvres des hauts plateaux",
      },
    },
    adminlevels: {
      admin0_name: { en: "Country", fr: "Pays" },
      admin1_name: { en: "Region", fr: "Région" },
      admin2_name: { en: "Sub-Region", fr: "Sous-région" },
    },
    levels: {
      low: { en: "Low", fr: "Faible" },
      moderate: { en: "Moderate", fr: "Modéré" },
      severe: { en: "Severe", fr: "Sévère" },
      extreme: { en: "Extreme", fr: "Extrême" },
      Vextreme: { en: "Very Extreme", fr: "Très Extrême" },
    },
    search: { en: "Search", fr: "Rechercher" },
    acVars: {
      domestic_violence: {
        en: "Domestic Safety",
        fr: "Sécurité Domestique",
      },
      gender_equity: {
        en: "Gender Equity",
        fr: "Égalité des sexes",
      },
      decision_making: {
        en: "Decision Making Power",
        fr: "Pouvoir de décision",
      },
      education: {
        en: "Womens Education",
        fr: "Éducation des femmes",
      },
      family_planning: {
        en: "Access to Family Planning",
        fr: "Accès à la planification familiale",
      },
      reproductive_health: {
        en: "Reproductive Health",
        fr: "Santé reproductive",
      },
      GSAP_poor215: {
        en: "% population under $2.15",
        fr: "% de la population sous 2,15$",
      },
      GSAP_poor365: {
        en: "% population under $3.65",
        fr: "% de la population sous 3,65$",
      },
      GSAP_poor685: {
        en: "% population under $6.85",
        fr: "% de la population sous 6,85$",
      },
      educationYrs: {
        en: "Education(Yrs)",
        fr: "Éducation (années)",
      },
    },
    adminNames: {
      "Full Country": { en: "Full Country", fr: "Pays Entier" },
      "Full Region": { en: "Full Region", fr: "Région complète" },
      Angola: {
        en: "Angola",
        fr: "Angola",
      },
      Benin: {
        en: "Benin",
        fr: "Bénin",
      },
      Botswana: {
        en: "Botswana",
        fr: "Botswana",
      },
      "Burkina Faso": {
        en: "Burkina Faso",
        fr: "Burkina Faso",
      },
      Burundi: {
        en: "Burundi",
        fr: "Burundi",
      },
      Cameroon: {
        en: "Cameroon",
        fr: "Cameroun",
      },
      "Central African Republic": {
        en: "Central African Republic",
        fr: "République Centrafricaine",
      },
      Chad: {
        en: "Chad",
        fr: "Tchad",
      },
      "Congo - Brazzaville": {
        en: "Congo - Brazzaville",
        fr: "Congo - Brazzaville",
      },
      "Congo - Kinshasa": {
        en: "Congo - Kinshasa",
        fr: "Congo - Kinshasa",
      },
      "Côte d’Ivoire": {
        en: "Côte d’Ivoire",
        fr: "Côte d’Ivoire",
      },
      Djibouti: {
        en: "Djibouti",
        fr: "Djibouti",
      },
      "Equatorial Guinea": {
        en: "Equatorial Guinea",
        fr: "Guinée Équatoriale",
      },
      Eritrea: {
        en: "Eritrea",
        fr: "Érythrée",
      },
      Eswatini: {
        en: "Eswatini",
        fr: "Eswatini",
      },
      Ethiopia: {
        en: "Ethiopia",
        fr: "Éthiopie",
      },
      Gabon: {
        en: "Gabon",
        fr: "Gabon",
      },
      Gambia: {
        en: "Gambia",
        fr: "Gambie",
      },
      Ghana: {
        en: "Ghana",
        fr: "Ghana",
      },
      Guinea: {
        en: "Guinea",
        fr: "Guinée",
      },
      "Guinea-Bissau": {
        en: "Guinea-Bissau",
        fr: "Guinée-Bissau",
      },
      Kenya: {
        en: "Kenya",
        fr: "Kenya",
      },
      Lesotho: {
        en: "Lesotho",
        fr: "Lesotho",
      },
      Liberia: {
        en: "Liberia",
        fr: "Libéria",
      },
      Madagascar: {
        en: "Madagascar",
        fr: "Madagascar",
      },
      Malawi: {
        en: "Malawi",
        fr: "Malawi",
      },
      Mali: {
        en: "Mali",
        fr: "Mali",
      },
      Mauritania: {
        en: "Mauritania",
        fr: "Mauritanie",
      },
      Mozambique: {
        en: "Mozambique",
        fr: "Mozambique",
      },
      Namibia: {
        en: "Namibia",
        fr: "Namibie",
      },
      Niger: {
        en: "Niger",
        fr: "Niger",
      },
      Nigeria: {
        en: "Nigeria",
        fr: "Nigéria",
      },
      Rwanda: {
        en: "Rwanda",
        fr: "Rwanda",
      },
      Senegal: {
        en: "Senegal",
        fr: "Sénégal",
      },
      "Sierra Leone": {
        en: "Sierra Leone",
        fr: "Sierra Leone",
      },
      Somalia: {
        en: "Somalia",
        fr: "Somalie",
      },
      "South Africa": {
        en: "South Africa",
        fr: "Afrique du Sud",
      },
      "South Sudan": {
        en: "South Sudan",
        fr: "Soudan du Sud",
      },
      Sudan: {
        en: "Sudan",
        fr: "Soudan",
      },
      Tanzania: {
        en: "Tanzania",
        fr: "Tanzanie",
      },
      Togo: {
        en: "Togo",
        fr: "Togo",
      },
      Uganda: {
        en: "Uganda",
        fr: "Ouganda",
      },
      Zambia: {
        en: "Zambia",
        fr: "Zambie",
      },
      Zimbabwe: {
        en: "Zimbabwe",
        fr: "Zimbabwe",
      },
      SSA: {
        en: "Sub-Saharan Africa",
        fr: "Afrique Subsaharienne",
      },
      "Sub-Saharan Africa": {
        en: "Sub-Saharan Africa",
        fr: "Afrique Subsaharienne",
      },
    },
    units: {
      index: { en: "Index", fr: "Indice" },
      days: { en: "Days", fr: "Jours" },
      yrs: { en: "Years", fr: "Années" },
      num_people: { en: "Num. People", fr: "Nb. Personnes" },
      num_animals: { en: "Num. Animals", fr: "Nb. Animaux" },
    },
    NoCode: { en: "No Code", fr: "Sans Code" },
  },
});
```

```{ojs}
definitionText = new Object({
  Hazard: {
    title: { en: "Hazard Definitions", fr: "Définitions des Aléas" },
    text: {
      en: `#### Max Human Heat Stress (HSH_max):  
**Thresholds:**

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 27                       |
| Moderate     | > 27 and ≤ 32              |
| High         | > 32 and ≤ 41              |
| Extreme      | > 41 and ≤ 54              |
| Very Extreme | > 54                       |

**Definition:** Human heat stress index, maximum value of the growing season.  
**Description:** The heat index (HI) is calculated using daily data and empirical equations based on Steadman (1979a; 1979b), relating the HI to dry-bulb temperature (°C) and relative humidity (%). The maximum value for each month is first calculated, followed by the climatological mean of each month, and then the maximum, mean, and median of the year.  
**Units:** Index (HI)  

#### Mean Human Heat Stress (HSH_mean):  
**Thresholds:** 

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 27                       |
| Moderate     | > 27 and ≤ 32              |
| High         | > 32 and ≤ 41              |
| Extreme      | > 41 and ≤ 54              |
| Very Extreme | > 54                       |

**Definition:** Human heat stress index, mean of the growing season.  
**Description:** The heat index (HI) is calculated using daily data and empirical equations based on Steadman (1979a; 1979b), relating the HI to dry-bulb temperature (°C) and relative humidity (%). The mean value for each month is first calculated, followed by the climatological mean of each month, and then the maximum, mean, and median of the year.  
**Units:** Index (HI)  

#### Number of Waterlogging Days (NDWL0):  
**Thresholds:**   

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 2                        |
| Moderate     | > 2 and ≤ 5                |
| High         | > 2 and ≤ 8                |
| Extreme      | > 8                        |

**Definition:** Total number of waterlogging days (at starting saturation, 0%) per season.  
**Description:** A waterlogging day occurs when the soil moisture is just above field capacity and moving toward saturation. This index is calculated using a simple water balance model that utilizes daily precipitation from CHIRPS, daily temperatures from CHIRTS, and solar radiation from AgERA5.  
**Units:** Days  

#### Number of Days of Water Stress (NDWS):  
**Thresholds:**   

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 15                       |
| Moderate     | > 15 and ≤ 20              |
| High         | > 20 and ≤ 25              |
| Extreme      | > 25                       |

**Definition:** Total number of water stress days per season.  
**Description:** A water stress day is defined as a day in which the ratio of actual to potential evapotranspiration is less than 0.5. This index is calculated using a simple water balance model that utilizes daily precipitation from CHIRPS, daily temperatures from CHIRTS, and solar radiation from AgERA5.  
**Units:** Days  

#### Number of Heat Stress Days for Maize (NTx35):  
**Thresholds:**  

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 10                       |
| Moderate     | > 10 and ≤ 20              |
| High         | > 20 and ≤ 25              |
| Extreme      | > 25                       |

**Definition:** Total number of heat stress days per season for maize.  
**Description:** The number of days with daily maximum temperatures above 35°C during the growing season, using a maize crop calendar.  
**Units:** Days  

#### Number of Heat Stress Days for Generic Crops (NTx40):  
**Thresholds:**  

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 1                        |
| Moderate     | > 1 and ≤ 5                |
| High         | > 5 and ≤ 10               |
| Extreme      | > 10                       |

**Definition:** Total number of heat stress days per season for generic crops.  
**Description:** The number of days with daily maximum temperatures above 40°C per month, without using a crop calendar.  
**Units:** Days  

#### Thornthwaite's Aridity Index (TAI):  
**Thresholds:**   

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 40                       |
| Moderate     | > 40 and ≤ 60              |
| High         | > 60 and ≤ 80              |
| Extreme      | > 80                       |

**Definition:** Thornthwaite's Aridity Index.  
**Description:** The Thornthwaite aridity index is calculated as 100 X (d / n), where d is the sum of monthly differences between precipitation and PET for months where precipitation is less than PET, and n is the sum of monthly PET for those months.  
**Units:** Index  

#### Max Cattle Thermal Humidity Index (THI_max):  
**Thresholds:**   

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 72                       |
| Moderate     | > 72 and ≤ 78              |
| High         | > 78 and ≤ 90              |
| Extreme      | > 90                       |

**Definition:** Cattle thermal humidity index, maximum value of the season.  
**Description:** The heat index (HI) for cattle is calculated using daily data and empirical equations based on Rahimi et al. (2020). The THI is calculated as THI1 = (1.8 × Tdb + 32) - [(0.55 - 0.0055 × RH) × (1.8 × Tdb - 26.8)], where Tdb is the dry bulb temperature (maximum temperature, °C), and RH is the relative humidity (%).  
**Units:** Index (THI)  

#### Mean Cattle Thermal Humidity Index (THI_mean):  
**Thresholds:**   

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 72                       |
| Moderate     | > 72 and ≤ 78              |
| High         | > 78 and ≤ 90              |
| Extreme      | > 90                       |

**Definition:** Cattle thermal humidity index, mean value of the season.  
**Description:** The heat index (HI) for cattle is calculated using daily data and empirical equations based on Rahimi et al. (2020). The THI is calculated as THI1 = (1.8 × Tdb + 32) - [(0.55 - 0.0055 × RH) × (1.8 × Tdb - 26.8)], where Tdb is the dry bulb temperature (maximum temperature, °C), and RH is the relative humidity (%).  
**Units:** Index (THI)  

#### Average Temperature (TAVG):  
**Thresholds:**  

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 33                       |
| Moderate     | > 33 and ≤ 36              |
| High         | > 38 and ≤ 47              |
| Extreme      | > 47                       |

**Definition:** Mean temperature.  
**Description:** The average temperature for a given period, typically calculated as the mean of daily temperatures.  
**Units:** °C  

#### Total Precipitation (PTOT):  
**Thresholds:**  

| Hazard Level | Value |
|--------------|----------------------------|
| Low          | ≤ 1200                     |
| Moderate     | > 1200 and ≤ 1600          |
| High         | > 1600 and ≤ 1800          |
| Extreme      | > 1800                     |

**Definition:** Total precipitation.  
**Description:** The total amount of precipitation accumulated over a specific period, typically a month or year.  
**Units:** mm`,
      fr: `#### Stress thermique humain maximal (HSH_max):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 27                       |
| Modéré         | > 27 et ≤ 32               |
| Sévère         | > 32 et ≤ 41               |
| Extrême        | > 41 et ≤ 54               |
| Très Extrême   | > 54                       |

**Définition:** Indice de stress thermique humain, valeur maximale de la saison de croissance.  
**Description:** L'indice de chaleur (HI) est calculé en utilisant des données quotidiennes et des équations empiriques basées sur Steadman (1979a; 1979b), reliant le HI à la température de l'air sec (°C) et à l'humidité relative (%). La valeur maximale pour chaque mois est d'abord calculée, suivie de la moyenne climatologique de chaque mois, puis des valeurs maximale, moyenne et médiane de l'année.  
**Unités:** Indice (HI)  

#### Stress thermique humain moyen (HSH_mean):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 27                       |
| Modéré         | > 27 et ≤ 32               |
| Sévère         | > 32 et ≤ 41               |
| Extrême        | > 41 et ≤ 54               |
| Très Extrême   | > 54                       |

**Définition:** Indice de stress thermique humain, moyenne de la saison de croissance.  
**Description:** L'indice de chaleur (HI) est calculé en utilisant des données quotidiennes et des équations empiriques basées sur Steadman (1979a; 1979b), reliant le HI à la température à bulbe sec (°C) et à l'humidité relative (%). La valeur moyenne pour chaque mois est d'abord calculée, suivie de la moyenne climatologique de chaque mois, puis des valeurs maximale, moyenne et médiane de l'année.  
**Unités:** Indice (HI)  

#### Nombre de jours de saturation en eau (NDWL0):  
**Seuils:**    

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 2                        |
| Modéré         | > 2 et ≤ 5                 |
| Sévère         | > 5 et ≤ 8                 |
| Extrême        | > 8                        |

**Définition:** Nombre total de jours de saturation en eau (à saturation initiale, 0 %) par saison.  
**Description:** Un jour de saturation en eau se produit lorsque l'humidité du sol est juste au-dessus de la capacité au champ et se dirige vers la saturation. Cet indice est calculé en utilisant un modèle simple de bilan hydrique qui utilise les précipitations quotidiennes de CHIRPS, les températures quotidiennes de CHIRTS et le rayonnement solaire d'AgERA5.  
**Unités:** Jours  

#### Nombre de jours de stress hydrique (NDWS):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 15                       |
| Modéré         | > 15 et ≤ 20               |
| Sévère         | > 20 et ≤ 25               |
| Extrême        | > 25                       |

**Définition:** Nombre total de jours de stress hydrique par saison.  
**Description:** Un jour de stress hydrique est défini comme un jour où le ratio de l'évapotranspiration réelle à l'évapotranspiration potentielle est inférieur à 0,5. Cet indice est calculé en utilisant un modèle simple de bilan hydrique qui utilise les précipitations quotidiennes de CHIRPS, les températures quotidiennes de CHIRTS et le rayonnement solaire d'AgERA5.  
**Unités:** Jours  

#### Nombre de jours de stress thermique pour le maïs (NTx35):  
**Seuils:**   

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 10                       |
| Modéré         | > 10 et ≤ 20               |
| Sévère         | > 20 et ≤ 25               |
| Extrême        | > 25                       |

**Définition:** Nombre total de jours de stress thermique par saison pour le maïs.  
**Description:** Le nombre de jours avec des températures maximales quotidiennes au-dessus de 35 °C pendant la saison de croissance, en utilisant un calendrier de culture du maïs.  
**Unités:** Jours  

#### Nombre de jours de stress thermique pour les cultures génériques (NTx40):  
**Seuils:**   

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 1                        |
| Modéré         | > 1 et ≤ 5                 |
| Sévère         | > 5 et ≤ 10                |
| Extrême        | > 10                       |

**Définition:** Nombre total de jours de stress thermique par saison pour les cultures génériques.  
**Description:** Le nombre de jours avec des températures maximales quotidiennes au-dessus de 40 °C par mois, sans utiliser de calendrier de culture.  
**Unités:** Jours  

#### Indice d'Aridité de Thornthwaite (TAI):  
**Seuils:**   

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 40                       |
| Modéré         | > 40 et ≤ 60               |
| Sévère         | > 60 et ≤ 80               |
| Extrême        | > 80                       |

**Définition:** Indice d'aridité de Thornthwaite.  
**Description:** L'indice d'aridité de Thornthwaite est calculé comme 100 × (d / n), où d est la somme des différences mensuelles entre les précipitations et l'ETP pour les mois où les précipitations sont inférieures à l'ETP, et n est la somme mensuelle de l'ETP pour ces mois.  
**Unités:** Indice  

#### Indice de Température-Humidité Maximal pour le Bétail (THI_max):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 72                       |
| Modéré         | > 72 et ≤ 78               |
| Sévère         | > 78 et ≤ 90               |
| Extrême        | > 90                       |

**Définition:** Indice de température-humidité pour le bétail, valeur maximale de la saison.  
**Description:** L'indice de chaleur (HI) pour le bétail est calculé en utilisant des données quotidiennes et des équations empiriques basées sur Rahimi et al. (2020). Le THI est calculé comme THI1 = (1,8 × Tdb + 32) - [(0,55 - 0,0055 × RH) × (1,8 × Tdb - 26,8)], où Tdb est la température à bulbe sec (température maximale, °C), et RH est l'humidité relative (%).  
**Unités:** Indice (THI)  

#### Indice de Température-Humidité Moyen pour le Bétail (THI_mean):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 72                       |
| Modéré         | > 72 et ≤ 78               |
| Sévère         | > 78 et ≤ 90               |
| Extrême        | > 90                       |

**Définition:** Indice de température-humidité pour le bétail, valeur moyenne de la saison.  
**Description:** L'indice de chaleur (HI) pour le bétail est calculé en utilisant des données quotidiennes et des équations empiriques basées sur Rahimi et al. (2020). Le THI est calculé comme THI1 = (1,8 × Tdb + 32) - [(0,55 - 0,0055 × RH) × (1,8 × Tdb - 26,8)], où Tdb est la température à bulbe sec (température maximale, °C), et RH est l'humidité relative (%).  
**Unités:** Indice (THI)  

#### Température Moyenne (TAVG):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 33                       |
| Modéré         | > 33 et ≤ 36               |
| Sévère         | > 36 et ≤ 47               |
| Extrême        | > 47                       |

**Définition:** Température moyenne.  
**Description:** La température moyenne pour une période donnée, généralement calculée comme la moyenne des températures quotidiennes.  
**Unités:** °C  

#### Précipitation Totale (PTOT):  
**Seuils:**  

| Niveau d'Aléas | Valeur |
|----------------|----------------------------|
| Faible         | ≤ 1200                     |
| Modéré         | > 1200 et ≤ 1600           |
| Sévère         | > 1600 et ≤ 1800           |
| Extrême        | > 1800                     |

**Définition:** Précipitation totale.  
**Description:** La quantité totale de précipitations accumulées sur une période spécifique, généralement un mois ou une année.  
**Unités:** mm`,
    },
  },
  Exposure: {
    title: { en: "Exposure Definitions", fr: "Définitions de l'Exposition" },
    text: {
      en: `#### Value Of Production (VOP):  
**Unit:** International Dollar for 2005 (Int$2005)  
**Description:** Value of Production (VOP) represents the total economic value of agricultural goods produced within a specified area.

#### Harvested Area (HA):
**Unit:** Hectare (ha)  
**Description:** Harvested area (HA) is the total land area, measured in hectares (ha), used for the cultivation of a crop within a given region.

#### Livestock Head (number):
**Unit:** Total  
**Description:** Livestock head refers to the total number of animals present in a given area.`,
      fr: `#### La Valeur de la Production (VOP)
**Unité:** Dollar International de 2005 (Int$2005)  
**Description:** La Valeur de la Production représente la valeur économique totale des biens agricoles produits dans une zone spécifiée.  

#### Superficie Récoltée (HA):
**Unité:** Hectare (ha)  
**Description:** La superficie récoltée est la superficie totale des terres, mesurée en hectares (ha), utilisée pour la culture d'une récolte dans une région donnée. 

#### Effectif du Bétail (nombre): 
**Unité:** Total  
**Description:** L'effectif du bétail fait référence au nombre total d'animaux présents dans une zone administrative donnée.`,
    },
  },
  Vulnerability: {
    title: {
      en: "Adaptive Capacity Definitions",
      fr: "Définitions de la Capacité d'Adaptation",
    },
    text: {
      en: `#### Education: 
**Description:** Years of education across the population (combined male and female)  
**Unit:** Years

#### Poverty: 
**Description:** Percent of Population underneath the provided poverty line  
**Unit:** % of Population

#### Gender: 
**Description:** A set of indexes showing female well-being. All are normalized between 0-1 where 0 is poor and 1 is good.  
**Unit:** Index
`,
      fr: `#### Éducation: 
**Description:**  Nombre d'années d'éducation dans la population (hommes et femmes combinés)  
**Unité:** Années

#### Pauvreté: 
**Description:** Pourcentage de la population en dessous du seuil de pauvreté fourni.  
**Unité:** % de la population

#### Genre: 
**Description:** Un ensemble d'indices montrant le bien-être des femmes. Tous sont normalisés entre 0 et 1, où 0 est mauvais et 1 est bon.  
**Unité:** Indice
`,
    },
  },
});
```
