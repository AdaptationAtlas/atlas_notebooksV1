/**
 * Returns HTML for a hero image with a centered title.
 *
 * The title is placed over a background color and is centered
 * horizontally and vertically.
 *
 * @param {string} nbTitle - The title to display.
 * @param {string} image_url - The URL of the hero image.
 * @returns {object} An object containing the HTML content for the hero image.
 */
function atlasHero(nbTitle, image_url) {
  return htl.html`
    <div id="hero-image" style="position: relative; width: 100%; max-width: 100%; overflow: visible; display: flex; justify-content: center;">
      <img src="${image_url}" style="width: 100%; height: 175px; object-fit: cover;" />
      <div style="position: absolute; bottom: 0; width: 60%; max-width: 90%; padding: 15px; display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center; background-color: white; z-index: 10; box-sizing: border-box;">
        <h1 class='title' id='notebook-title' style="all: unset; font-size: 28px; font-weight: 700; word-wrap: break-word; line-height: 1.2;">${nbTitle}</h1>
      </div>
    </div>`
}


/**
 * Converts an array of objects into a CSV string.
 *
 * @param {Array<object>} data - The data to convert, where each object represents a row.
 * @returns {string} A CSV formatted string representing the input data.
 *                   Returns an empty string if the input data is empty or not provided.
 * 
 * Each object's keys are used as CSV column headers. Values are escaped if they contain
 * commas, quotes, or newlines. Null or undefined values are converted to empty strings.
 */
function convertToCSV(data) {
  if (!data?.length) return '';
  
  const headers = Object.keys(data[0]);
  const escapeValue = val => {
    if (val == null) return '';
    const str = String(val);
    return str.includes(',') || str.includes('"') || str.includes('\n') 
      ? `"${str.replace(/"/g, '""')}"` : str;
  };
  
  return [
    headers.map(escapeValue).join(','),
    ...data.map(row => headers.map(key => escapeValue(row[key])).join(','))
  ].join('\n');
};

/**
 * Generate a download button for a given dataset.
 * @param {Array<object>} data - The dataset to download.
 * @param {string} filename - The name of the file to download.
 */
function downloadData(data, filename) {
  const filename_csv = filename + ".csv";
  const blob = new Blob([convertToCSV(data)], { type: 'text/csv;charset=utf-8;' });
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.setAttribute('download', filename_csv);
  document.body.appendChild(link);
  link.style.display = 'none';
  link.click();

  window.URL.revokeObjectURL(url);
  document.body.removeChild(link);
}


/**
 * Create a button that downloads the given dataset as a CSV file.
 * @param {Array<object>} data - The dataset to download.
 * @param {string} filename - The name of the file to download (without the .csv extension).
 * @param {string} [label="Download"] - The label to display on the button.
 * @returns {Button} - The download button.
 */
function downloadButton(data, filename, label = "Download") {
  return Inputs.button(label, {reduce: () => downloadData(data, filename)})
}



/**
 * Creates a table of contents (ToC) for the notebook.
 * 
 * The ToC is a dynamic list of links to headings in the notebook. The ToC is
 * generated by observing the DOM for changes to headings and regenerating the ToC
 * when changes are detected.
 * 
 * 
 * @param {Object} options - Configuration options
 * @param {string} [options.selector="h1"] - CSS selector for heading elements to include in the TOC
 * @param {string} [options.heading="<b>In this notebook</b>"] - HTML for the TOC heading
 * @param {string} [options.delim="&nbsp;|&nbsp;"] - HTML delimiter between TOC entries
 * @param {Array<string>} [options.skip=["notebook-title"]] - Elements to exclude (by id, class, or text content)
 * @param {string} [options.activeClass="active"] - CSS class applied to the currently active TOC link
 * 
 * @returns {Generator} A generator that produces HTML content representing the table of contents.
 */
function atlasTOC({
  selector = "h1",
  heading = "<b>In this notebook</b>",
  delim = '&nbsp;|&nbsp;',
  skip = ['notebook-title'],
  activeClass = "active",
} = {}) {

  return Generators.observe(notify => {
    let headings = [];
    let links = [];
    let timeout;

    function observed() {
      clearTimeout(timeout);
      timeout = setTimeout(() => {

        const h = Array.from(document.querySelectorAll(selector))
          .filter(d => 
            !skip.some(value => 
              d.parentElement.id === value ||
              d.id === value ||
              d.textContent === value || 
              d.className === value
            )
          );

        if (h.length === headings.length && h.every((el, i) => el === headings[i
        ])) return;

        headings = h;
        links = headings.map(createLink);

        notify(html`${heading
        }<br>${
          headings.length 
            ? links.map((link, i) => html`<span>${link
          }${i < links.length - 1 ? delim : ''
          }</span>`)
            : html`<span>No headings found.</span>`
        }`);
        onScroll()
      },
      5);
    }

    function createLink(h) {
      const section_id = h.parentElement.id
      const link = html`
      <a class='toc-link' href=#${section_id}>
        ${DOM.text(h.textContent)}
      </a>`;
      link.onclick = e => {
        e.preventDefault();
        h.scrollIntoView({ behavior: 'smooth'
        });
        setActiveLink(link);
      };
      return link;
    }

    function setActiveLink(activeLink) {
      links.forEach(link => link.classList.toggle(activeClass, link === activeLink));
    }

    function onScroll() {
      const closest = links[headings
        .map(h => Math.abs(h.getBoundingClientRect().top))
        .reduce((minIdx, dist, i, arr) => dist < arr[minIdx
        ] ? i : minIdx,
        0)
      ];
      setActiveLink(closest);
    }

    const observer = new MutationObserver(observed);
    observer.observe(document.body,
    { childList: true, subtree: true
    });
    window.addEventListener('scroll', onScroll);

    observed();
    onScroll();

    return () => {
      observer.disconnect();
      window.removeEventListener('scroll', onScroll);
    };
  });
}

// /**
//  * Creates a language selector for the navbar.
//  * @param {Object} language_obj An object that maps language codes to their full names.
//  * @param {string} masterLanguage
//  * @returns {void}
//  * @example
//  * 
//  * viewof masterLanguage = Inputs.radio(languages, {
//  *   label: "Main language toggle",
//  *   format: (d) => d.key,
//  *   value: languages.find((x) => x.key === defaultLangKey),
//  * })
//  *
//  * NavbarLangSelector({en: "English", fr: "Fran ais"}, masterLanguage);
//  */
// function NavbarLangSelector(language_obj, masterLanguage) {
//   let navEnd = document.querySelector(".navbar-nav.ms-auto .nav-item.compact");
//   if (navEnd) {
//     let existingLangSelector = document.getElementById("nav-lang-selector");
//     if (!existingLangSelector) {
//       let lang_sel = Inputs.bind(
//         Inputs.radio(language_obj, {
//           label: "",
//           format: (d) => d.label
//         }),
//         viewof masterLanguage
//       );
//       lang_sel.id = "nav-lang-selector";
      
//       // Hack the css together for the observable inputs
//       lang_sel.style.display = "flex";
//       lang_sel.style.alignItems = "center";
//       lang_sel.style.marginLeft = "10px";
//       let lang_div = lang_sel.querySelector("div");
//       lang_div.style.display = "flex";
//       lang_div.style.flexDirection = "column";

//       // Insert the new item after the GitHub icon and other elements
//       navEnd.parentNode.appendChild(lang_sel);
//     }
//   }
// }